<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Yuyinzi&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Yuyinzi&#39;s blog">
<meta property="og:url" content="http://yuyinzi.github.io/index.html">
<meta property="og:site_name" content="Yuyinzi&#39;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Yuyinzi&#39;s blog">
  
    <link rel="alternate" href="/atom.xml" title="Yuyinzi&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/may.jpeg">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yuyinzi.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Yuyinzi&#39;s blog</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Django笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/16/Django笔记/" class="article-date">
  <time datetime="2019-04-16T06:24:09.000Z" itemprop="datePublished">2019-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/16/Django笔记/">Django笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>随手记录一些<code>Django</code>发现的知识点。</p>
<h2 id="as-view"><a href="#as-view" class="headerlink" title="as_view`"></a>as_view`</h2><p>当在<code>view</code>中采用<code>class-based-view</code>方法时，必须要在<code>url</code>中使用<code>as_view()</code>。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># views.py</span></span><br><span class="line"><span class="keyword">from</span> django.views.generic <span class="keyword">import</span> View</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">"Hello"</span>)</span><br><span class="line">      </span><br><span class="line"><span class="comment"># urls.py</span></span><br><span class="line"><span class="keyword">from</span> fun.views <span class="keyword">import</span> Hello</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    ...</span><br><span class="line">    path(<span class="string">'hello/'</span>, Hello.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>查看<code>as_views</code>源码发现，它是返回一个可以被调用的<code>view</code>，这个<code>view</code>可以接受<code>request</code>，并且返回一个<code>response</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Hello</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">fun</span>.<span class="title">views</span>.<span class="title">Hello</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; my_callable_view = Hello.as_view()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_callable_view</span><br><span class="line">&lt;function Hello at <span class="number">0x114b9ff28</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>request</span><br><span class="line">&lt;WSGIRequest: GET <span class="string">'/hello/'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response = my_callable_view(request)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response</span><br><span class="line">&lt;HttpResponse status_code=<span class="number">200</span>, <span class="string">"text/html; charset=utf-8"</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>response.content</span><br><span class="line"><span class="string">b'Hello'</span></span><br></pre></td></tr></table></figure>
<h2 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a><code>dispatch</code></h2><p>提到<code>as_view</code>就不得不提到<code>dispatch</code>方法，因为即使使用<code>as_view</code>，最终调用的仍然是实例的<code>dispatch</code>方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dispatch</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">  <span class="comment"># Try to dispatch to the right method; if a method doesn't exist,</span></span><br><span class="line">  <span class="comment"># defer to the error handler. Also defer to the error handler if the</span></span><br><span class="line">  <span class="comment"># request method isn't on the approved list.</span></span><br><span class="line">  <span class="keyword">if</span> request.method.lower() <span class="keyword">in</span> self.http_method_names:</span><br><span class="line">    handler = getattr(self, request.method.lower(), self.http_method_not_allowed)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      handler = self.http_method_not_allowed</span><br><span class="line">      <span class="keyword">return</span> handler(request, *args, **kwargs)</span><br></pre></td></tr></table></figure>
<p>它会查找实例中是否存在一个同名的<code>request.method</code>方法，如果没有找到对应的方法，将会返回一个<code>HttpResponseNotAllowed</code>。</p>
<p>如果重载了<code>dispatch</code>方法，将会影响到全部的视图类方法函数，所以我通常选择在上面加<code>method_decorator</code>装饰器，例如，添加缓存：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.generic <span class="keyword">import</span> View</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.cache <span class="keyword">import</span> cache_page</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.utils.decorators <span class="keyword">import</span> method_decorator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="comment"># 模拟耗时操作</span></span><br><span class="line">        <span class="keyword">import</span> time</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">"Hello"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 增加15分钟的缓存</span></span><br><span class="line"><span class="meta">    @method_decorator(cache_page(15*60))</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> super(Hello, self).dispatch(request, *args, **kwargs)</span><br></pre></td></tr></table></figure>
<p>这个方法和在<code>urls.py</code>添加缓存是一样的。</p>
<h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a><code>reverse</code></h2><p>因为以前一直使用前后端分离，基本没有遇到过在<code>view</code>中需要进行重定向的问题，所以对<code>reverse</code>的用法一直略显生疏。它可以防止当一个<code>url</code>更名后，全局所有的引用都得跟着改变：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># urls.py</span></span><br><span class="line">...</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'hello/'</span>, Hello.as_view(), name=<span class="string">'hello'</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.urls <span class="keyword">import</span> reverse</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reverse(<span class="string">'hello'</span>)</span><br><span class="line"><span class="string">'/hello/'</span></span><br></pre></td></tr></table></figure>
<h2 id="中间件-Middlewares"><a href="#中间件-Middlewares" class="headerlink" title="中间件(Middlewares)"></a>中间件(<code>Middlewares</code>)</h2><p>它有五个接口：</p>
<ul>
<li><p><code>process_request(self, request)</code>：该方法在请求被决定使用哪个<code>view</code>之前调用，会返回<code>None</code>或者<code>HttpResponse</code>对象。</p>
</li>
<li><p><code>process_view(self , request, callback , callback_args,  callback_kwargs)</code>：<code>callback</code>是请求被决定使用的<code>view</code>函数，<code>callback_args</code>和<code>callback_kwargs</code>是<code>view</code>锁需要接受的参数，它返回<code>None</code>或者<code>HttpResponse</code>。</p>
</li>
<li><p><code>process_template_response(self, request, response):</code>response<code>是一个由</code>Django view<code>或者中间件返回的</code>TemplateResponse <code>对象,</code>process_template_response()<code>在</code>view<code>使用</code>render<code>渲染一个模版对象完成之后被调用，它必须返回一个</code>render<code>方法执行后的</code>response`对象。</p>
</li>
<li><p><code>process_response</code>(<code>self</code>, <code>request</code>, <code>response</code>)：<code>response</code> 是一个<code>django view</code>或者中间件返回的<code>HttpResponse</code>或者<code>StreamingHttpResponse</code>对象，<code>process_response</code>会在所有响应到达浏览器之前被调用</p>
</li>
<li><p><code>process_exception</code>(<code>self</code>, <code>request</code>, <code>exception</code>)：<code>exception</code>是<code>view</code>函数中<code>raise</code>的<code>Exception</code>对象，当<code>view</code>函数<code>raise</code>一个<code>exception</code>的时候调用<code>process_exception</code>，它会返回<code>None</code>或<code>HttpResponse</code>对象。</p>
</li>
</ul>
<h3 id="process-request"><a href="#process-request" class="headerlink" title="process_request"></a><code>process_request</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fun/middlewares.py</span></span><br><span class="line"><span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMiddleware</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> request.META[<span class="string">'HTTP_USER_AGENT'</span>] == <span class="string">'PostmanRuntime/7.6.1'</span>:</span><br><span class="line">            request.META[<span class="string">'user_name'</span>] = <span class="string">'Postman'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            request.META[<span class="string">'user_name'</span>] = <span class="string">'Chrome'</span></span><br><span class="line">            </span><br><span class="line"><span class="comment"># fun/views.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        user_name = request.META.get(<span class="string">'user_name'</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">"Hello "</span> + user_name)</span><br></pre></td></tr></table></figure>
<p>采用<code>Postman</code>和浏览器访问分别能得到不同的结果。</p>
<h3 id="process-view"><a href="#process-view" class="headerlink" title="process_view"></a><code>process_view</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新增process_view，打印需要调用的view的名称</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMiddleware</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> request.META[<span class="string">'HTTP_USER_AGENT'</span>] == <span class="string">'PostmanRuntime/7.6.1'</span>:</span><br><span class="line">            request.META[<span class="string">'user_name'</span>] = <span class="string">'Postman'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            request.META[<span class="string">'user_name'</span>] = <span class="string">'Chrome'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span><span class="params">(self, request, callback, callback_args, callback_kwargs)</span>:</span></span><br><span class="line">        print(callback.__name__)</span><br></pre></td></tr></table></figure>
<p>输出结果都是：<code>Hello</code></p>
<h3 id="process-template-response"><a href="#process-template-response" class="headerlink" title="process_template_response"></a><code>process_template_response</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMiddleware</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_template_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        print(response)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      </span><br><span class="line"> <span class="comment"># views中需要有TemplateResponse</span></span><br><span class="line"><span class="keyword">from</span> django.template.response <span class="keyword">import</span> TemplateResponse</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        user_name = request.META.get(<span class="string">'user_name'</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="comment"># return HttpResponse("Hello " + user_name</span></span><br><span class="line">        print(<span class="string">"Hello"</span>+user_name)</span><br><span class="line">        <span class="keyword">return</span> TemplateResponse(request, <span class="string">'hello.html'</span>)</span><br></pre></td></tr></table></figure>
<p><code>render</code>会直接将模板渲染，并返回一个<code>HttpResponse</code>，所以使用<code>TemplateResponse</code>可以拦截一下渲染后的<code>Response</code>。</p>
<h3 id="process-response"><a href="#process-response" class="headerlink" title="process_response"></a><code>process_response</code></h3><p>可以基于此接口，再修改返回的<code>response</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMiddleware</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">		...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        print(response)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">"Hi "</span> + response.content.decode(<span class="string">'utf-8'</span>).split()[<span class="number">-1</span>])</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"><span class="comment"># views.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        user_name = request.META.get(<span class="string">'user_name'</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">"Hello "</span> + user_name)</span><br></pre></td></tr></table></figure>
<p>输出会从<code>Hello Postman</code>变成<code>Hi Postman</code></p>
<h3 id="procee-exception"><a href="#procee-exception" class="headerlink" title="procee_exception"></a><code>procee_exception</code></h3><p>这个接口可以很方便的拦截异常：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMiddleware</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">		...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_exception</span><span class="params">(self, request, exception)</span>:</span></span><br><span class="line">        print(exception)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">"啊哦，服务器开小差了~"</span>)</span><br><span class="line">      </span><br><span class="line"><span class="comment"># views.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">      	<span class="comment"># 出现一个KeyError</span></span><br><span class="line">        user_name = request.META.get(<span class="string">'user_names'</span>)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">"Hello "</span> + user_name)</span><br></pre></td></tr></table></figure>
<p>异常会打印在终端，而浏览器访问会返回<code>Hi 啊哦，服务器开小差了~</code>，可见它是先处理<code>process_exception</code>(在有异常的情况下)，并将其<code>response</code>返回给<code>process_response</code>处理。</p>
<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>执行顺序如下图所示：</p>
<p><img src="/assets/执行顺序.png" alt="执行顺序"></p>
<p>在<code>1.10</code>版本后，如果<code>process_request</code>没有返回<code>None</code>，这个请求将会返回给同一层的中间件。</p>
<p>首先添加一个新的中间件，在<code>settings</code>中放在<code>TestMiddleware</code>后面：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fun/middlewares.py</span></span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherTestMiddleware</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> request.META[<span class="string">'HTTP_USER_AGENT'</span>] == <span class="string">'PostmanRuntime/7.6.1'</span>:</span><br><span class="line">            request.META[<span class="string">'user_name'</span>] = <span class="string">'NewPostman'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            request.META[<span class="string">'user_name'</span>] = <span class="string">'NewChrome'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span><span class="params">(self, request, callback, callback_args, callback_kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'New'</span>, callback.__name__)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_template_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        print(<span class="string">'New'</span>, response)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        print(<span class="string">'New'</span>, response)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">"Hi "</span> + response.content.decode(<span class="string">'utf-8'</span>).split()[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_exception</span><span class="params">(self, request, exception)</span>:</span></span><br><span class="line">        print(<span class="string">'New'</span>, exception)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">"啊哦，服务器开小差了~"</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">New Hello</span><br><span class="line">New &lt;HttpResponse status_code=200, "text/html; charset=utf-8"&gt;</span><br><span class="line">&lt;HttpResponse status_code=200, "text/html; charset=utf-8"&gt;</span><br></pre></td></tr></table></figure>
<p>如果为原本的<code>TestMiddleware</code>的<code>process_request</code>添加个返回，那么<code>AnotherMiddleware</code>中的函数都不会执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMiddleware</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> request.META[<span class="string">'HTTP_USER_AGENT'</span>] == <span class="string">'PostmanRuntime/7.6.1'</span>:</span><br><span class="line">            request.META[<span class="string">'user_name'</span>] = <span class="string">'Postman'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            request.META[<span class="string">'user_name'</span>] = <span class="string">'Chrome'</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">"StopTest"</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;HttpResponse status_code=200, "text/html; charset=utf-8"&gt;</span><br></pre></td></tr></table></figure>
<p>而当出现了异常时，是由后面的<code>AnotherMiddleware</code>所处理的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Quit the server with CONTROL-C.</span><br><span class="line">Hello</span><br><span class="line">New Hello</span><br><span class="line">New can only concatenate str (not "NoneType") to str</span><br><span class="line">New &lt;HttpResponse status_code=200, "text/html; charset=utf-8"&gt;</span><br><span class="line">&lt;HttpResponse status_code=200, "text/html; charset=utf-8"&gt;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuyinzi.github.io/2019/04/16/Django笔记/" data-id="cjujlwkk2000cg28zu1nlbyd0" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Django/">Django</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-《Redis设计与实现》读书笔记-第三-四部分" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/15/《Redis设计与实现》读书笔记-第三-四部分/" class="article-date">
  <time datetime="2019-04-15T06:25:56.000Z" itemprop="datePublished">2019-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/15/《Redis设计与实现》读书笔记-第三-四部分/">《Redis设计与实现》读书笔记 第三/四部分</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>因为第四部分只挑了感兴趣的部分看，于是将第三第四部分合并起来。主要介绍的有：</p>
<ul>
<li><code>redis</code>是如何实现主从一致的</li>
<li><code>redis</code>的<code>sentinel</code>是什么</li>
</ul>
<h2 id="第十五章-复制"><a href="#第十五章-复制" class="headerlink" title="第十五章 复制"></a>第十五章 复制</h2><p>用户可以通过执行<code>SLAVEOF</code>命令让一个服务器(从服务器)去复制另一个服务器(主服务器)。复制功能包括同步(<code>sync</code>)和命令传播(<code>command propagate</code>)：</p>
<ul>
<li>同步用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态；</li>
<li>命令传播用户当主服务器<strong>被修改</strong>时，让主从服务器恢复到一致状态。 </li>
</ul>
<p>针对<code>2.8</code>版本以前采用的是旧版复制，具有较大的性能缺陷。 </p>
<h3 id="旧版复制"><a href="#旧版复制" class="headerlink" title="旧版复制"></a>旧版复制</h3><p>同步操作是通过由从服务器向主服务器发送<code>SYNC</code>命令完成的，主要包括两个部分： </p>
<ul>
<li><p>主服务器收到命令后，使用<code>BGSAVE</code>生成<code>RDB</code>，并且将<code>RDB</code>文件发送给从服务器，从服务器载入<code>RDB</code>文件； </p>
</li>
<li><p>主服务器将执行<code>BGSAVE</code>命令(但没执行完)时保存在缓冲区里的写命令发送给从服务器。 </p>
</li>
</ul>
<p>同步操作完毕之后，需要根据命令传播保持主从数据库的一致。但是如果<strong>在命令传播的过程中</strong>，发生了<strong>主从服务器断线</strong>，从服务器仍然会向主服务器发送<code>SYNC</code>命令，即主数据库会重新执行<code>BGSAVE</code>生成<code>RDB</code>文件，其中包含了断线前已经同步的数据，是没有必要的。 </p>
<blockquote>
<p><code>SYNC</code>命令十分耗费资源，因为在生成<code>RDB</code>的过程中，会耗费主服务器大量的<code>CPU</code>、内存和磁盘<code>I/O</code>资源；在发送<code>RDB</code>的过程中，会占用主从服务器大量的带宽；接收到<code>RDB</code>文件的从服务器需要载入，此时会发生阻塞。 </p>
</blockquote>
<h3 id="新版复制"><a href="#新版复制" class="headerlink" title="新版复制"></a>新版复制</h3><p>新版复制主要可以解决旧版复制功能处理断线重复复制的低效问题，它使用<code>PSYNC</code>替代<code>SYNC</code>，具有完整重同步和部分重同步两种模式： </p>
<ul>
<li><p>完整重同步用于初次复制情况，和<code>SYNC</code>处理方式一致 </p>
</li>
<li><p>部分重同步用于处理断线重复制情况，只需要将从服务器缺少的写命令发送给从服务器即可。 </p>
</li>
</ul>
<p>部分重同步的实现在于，需要记录三个部分： </p>
<ul>
<li><p>主从服务器的复制偏移量：主服务器通过比对与重服务器中数据的偏移量是否一致，判断主从服务器是否处于一致状态。 </p>
</li>
<li><p>主服务器的复制积压缓冲区：当主从数据库的复制偏移量不一致时，会判断复制积压缓冲区中是否存在偏移量之后的数据(<strong>复制积压区是一个固定长度的先进先出队列</strong>)。如果数据仍然存在，则进行部分重同步操作；否则执行完整重同步操作。由于复制积压区固定长度，所以需要针对网络断线情况以及主服务器接受的命令数来合理调整其大小。 </p>
</li>
<li><p>服务器的运行<code>ID</code>：从服务器中会保存主服务器的运行<code>ID</code>，当断线重连后，从服务器会重新发送该<code>ID</code>，如果与主服务器<code>ID</code>一致，主服务器可以继续执行部分重同步操作，否则执行完整重同步操作。 </p>
</li>
</ul>
<p>如果是初次复制操作，从服务器会发送<code>PSYNC ? -1</code>，否则发送<code>PSYNC &lt;runid&gt; &lt;offset&gt;</code>，主服务器会根据情况判断进行完整重同步还是部分重同步操作。 </p>
<h3 id="复制的实现"><a href="#复制的实现" class="headerlink" title="复制的实现"></a>复制的实现</h3><ul>
<li><p>客户端设置主服务器的地址和端口，保存到从服务器的<code>redisServer</code>中，只有当保存工作完成之后，复制工作才会真正开始； </p>
</li>
<li><p>从服务器与主服务器之间建立套接字连接，从服务器会为它关联一个专门用于处理复制工作的文件事件处理器，负责接收<code>RDB</code>文件，接收传播来的写命令等； </p>
</li>
<li><p>从服务器发送<code>PING</code>命令，用来检查套接字的读写状态是否正常以及主服务器是否能够正常处理命令请求(若没有出现<code>PONG</code>的回复，则表示异常，需要重新建立套接字)； </p>
</li>
<li><p>身份验证，如果主服务器设置了<code>requirepass</code>，服务器也需要设置<code>masterauth</code>，要么都不设置，否则都会使得从服务器目前的复制工作终端，并从创建套接字开始重新执行，直到身份验证通过或者从服务器主动放弃复制； </p>
</li>
<li><p>从服务器发送<code>REPLCONF listening-port &lt;port-number&gt;</code>，主服务器会将该端口号记录在客户端状态中，主要用于<code>INFO replication</code>的打印中； </p>
</li>
<li><p>从服务器发送<code>PSYNC</code>执行同步，执行以后<strong>主从服务器互为双方的客户端</strong>，因为主服务器需要将缓冲区/复制积压缓冲区的写命令发送给从服务器。 </p>
</li>
<li><p>完成同步之后，进入命令传播阶段。 主服务器只要一直讲命令发送给从服务器，从服务器只要一直接收主服务器的命令，就可以保证主从服务器一致了。</p>
</li>
</ul>
<h3 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h3><p><strong>命令传播</strong>阶段，从服务器默认<code>1s</code>的频率向主服务器发送<code>REPLCONF ACK &lt;replication_offset&gt;</code>，<code>replication_offset</code>是从服务器当前的复制偏移量，有三个用途： </p>
<ul>
<li><p>检测主从服务器的网络连接，如果主服务器超过<code>1s</code>没有收到从服务器的<code>ACK</code>命令(可以通过<code>INFO replication</code>的<code>lag</code>看到)，说明主从服务器的连接出现了故障。 </p>
</li>
<li><p>辅助实现<code>min-slaves</code>配置，主服务器可以提供<code>min-slaves-to-write</code>(要求写入时的从服务器数量)和<code>min-slaves-max-lag</code>(要求写入时的从服务器延迟)，防止在不安全的情况下执行写命令。 </p>
</li>
<li><p>检测命令丢失，如果在命令传播中发生了写命令丢失的情况，主服务器仍然可以根据复制偏移量将这些数据重新发送给从服务器(类似<code>TCP</code>中的<code>ack</code>)。 </p>
</li>
</ul>
<blockquote>
<p>补发缺失数据操作在主从服务器没有断线的情况下执行，部分重同步操作在断线重连的情况下执行。 </p>
</blockquote>
<h2 id="第十六章-Sentinel"><a href="#第十六章-Sentinel" class="headerlink" title="第十六章 Sentinel"></a>第十六章 <code>Sentinel</code></h2><p><code>Sentinel</code>(哨兵)系统可以监视任意多个主服务器，以及主服务器下的所有从服务器，并且当主服务器下线时将从服务器升级为新的主服务器，选举局部<code>Sentinel</code>领头以及<code>Sentinel</code>领头。 </p>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>可以使用: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>redis-server /path/to/your/sentinel.conf --sentinel</span><br></pre></td></tr></table></figure>
<p>或者 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>redis-sentinel /path/to/your/sentinel.conf</span><br></pre></td></tr></table></figure>
<p>启动一个<code>sentinel</code>服务器。 </p>
<p>实际上，它是一个运行在<strong>特殊模式下的<code>redis</code>服务器</strong>。但是它不使用数据库，不会载入<code>RDB</code>或者<code>AOF</code>文件，端口使用<code>REDIS_SENTINEL_PORT</code>指定(普通<code>redis</code>服务器端口使用<code>REDIS_SERVERPORT</code>)，它只支持<code>PING</code>/<code>SENTINEL</code>/<code>INFO</code>/<code>SUBSCRIBE</code>/<code>UNSUBSCRIBE</code>/<code>PSUBSCRIBE</code>和<code>PUNSUBSCRIBE</code>七个命令。 </p>
<p>基本数据结构： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sentinelState</span>&#123;</span> </span><br><span class="line">  <span class="comment">// 当前纪元，同一纪元下sentinel领头不能发生变化 </span></span><br><span class="line">  <span class="keyword">unint64_t</span> current_epoch; </span><br><span class="line">  <span class="comment">// 记录所有被监视的主服务器相关信息 </span></span><br><span class="line">  dict * masters; </span><br><span class="line">  ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>masters</code>保存了<code>sentinelRedisInstance</code>结构，每一个结构代表被<code>sentinel</code>监视的<code>redis</code>服务器实例(包括主服务器，从服务器，或者是另外的<code>sentinel</code>)。它结构体如下： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sentinelRedisInstance</span>&#123;</span> </span><br><span class="line">  <span class="comment">// 实例名字/运行id </span></span><br><span class="line">  <span class="keyword">char</span> * name; </span><br><span class="line">  <span class="keyword">char</span> * runid; </span><br><span class="line">  <span class="keyword">unit64_t</span> config_epoch; </span><br><span class="line">  <span class="comment">// 实例响应超过down_after_period，会判断主观下线 </span></span><br><span class="line">  <span class="keyword">mstime_t</span> down_after_period; </span><br><span class="line">  <span class="comment">// 判断实例客观下线需要的投票数量 </span></span><br><span class="line">  <span class="keyword">int</span> quorum; </span><br><span class="line">  dict * slaves; </span><br><span class="line">  <span class="comment">// 所有监视该服务器的sentinel </span></span><br><span class="line">  dict * sentinels; </span><br><span class="line">  ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当初始化完成之后，<code>sentinel</code>将成为主服务器的客户端。它会与主服务器创建<code>2</code>个异步网络连接： </p>
<ul>
<li><p>命令连接，用于发送命令与接收命令回复。 </p>
</li>
<li><p>订阅连接，用于订阅主服务器的<code>__sentinel__:hello</code>频道 </p>
</li>
</ul>
<h3 id="获取主服务器信息"><a href="#获取主服务器信息" class="headerlink" title="获取主服务器信息"></a>获取主服务器信息</h3><p><code>sentinel</code>默认每<code>10s</code>一次向主服务器发送<code>INFO</code>，根据回复可以获得： </p>
<ul>
<li><p>主服务器本身的运行<code>id</code>，以及<code>role</code>域记录的服务器角色； </p>
</li>
<li><p>主服务器下所有从服务器的信息，用来更新主服务器<code>sentinelRedisInstance</code>中的<code>slaves</code>字典 </p>
</li>
</ul>
<h3 id="获取从服务器信息"><a href="#获取从服务器信息" class="headerlink" title="获取从服务器信息"></a>获取从服务器信息</h3><p>由上面所说可以发现，<code>sentinel</code>可以自动发现从服务器。</p>
<p>当发现主服务器有新的从服务器出现时，<code>sentinel</code>不仅会为新的从服务器创建相应的实例结构，还会<strong>创建到从服务器的命令连接和订阅连接</strong>。也是默认每<code>10s</code>向从服务器发送<code>INFO</code>，获得从服务器的运行<code>id</code>，<code>ip</code>以及优先级、偏移量、连接状态等(为了方便以后将从服务器升级为主服务器)。 </p>
<h3 id="发现-更新sentinel信息"><a href="#发现-更新sentinel信息" class="headerlink" title="发现/更新sentinel信息"></a>发现/更新<code>sentinel</code>信息</h3><p>默认情况下，<code>sentinel</code>会每隔<code>2s</code>向被监视的主/从服务器的<code>__sentinel__:hello</code>频道发送消息。对于监视同一个服务器的多个<code>sentinel</code>来说，一个<code>sentinel</code>发送的信息会被其他<code>sentinel</code>接收，用以互相更新<code>sentinel</code>之间的认知：当一个<code>sentinel</code>接收到其他<code>sentinel</code>(源)发送而来的信息时，会在自己的<code>masters</code>字典中查找对应的主服务器实例结构，检查其<code>sentinels</code>中是否存在源<code>sentinel</code>并进行更新(不存在说明源<code>sentinel</code>刚开始监视该主服务器，此时需要创建并添加到<code>sentinels</code>中)。因此，监视同一个主服务器的多个<code>sentinel</code>可以自动发现对方。 </p>
<blockquote>
<p>监视同一主服务器的<code>sentinel</code>之间会创建命令连接，并不会创建订阅连接。订阅连接用来发现新的<code>sentinel</code>。 </p>
</blockquote>
<h3 id="检测主观-客观下线"><a href="#检测主观-客观下线" class="headerlink" title="检测主观/客观下线"></a>检测主观/客观下线</h3><p>默认情况，<code>sentinel</code>会以<code>1s</code>的频率向其他创建命令连接的实例(主/从服务器)，其他<code>sentinel</code>发送<code>PING</code>命令判断实例是否在线。 </p>
<p><strong>主观下线</strong>： </p>
<p>如果一个实例在<code>down_after_milliseconds</code>时间(这个时间也适用于主服务器下所有从服务器，以及监视主服务器的其他<code>sentinel</code>。多个<code>sentinel</code>设置的时间可以不同，即不同<code>sentinel</code>认为同一实例主观下线的标准并不一致)内连续向<code>sentinel</code>返回无效回复，<code>sentinel</code>对在创建的实例中的<code>flags</code>修改为<code>SRI_S_DOWN</code>，表示它认为此实例已经进入主观下线。 </p>
<p><strong>客观下线</strong>： </p>
<p>当<code>sentinel</code>判断主服务器已经主观下线之后，会向其他监视主服务器的<code>sentinel</code>询问是否他们也认为主服务器已经下线。当接收到足够数量(<code>quorum</code>)的下线判断时，<code>sentinel</code>会将从服务器判定为客观下线(不同<code>sentinel</code>认为同一实例客观下线的标准也并不一致)。此时<code>flags</code>标记为<code>SRI_O_DOWN</code>。客观下线条件只适用于主服务器。</p>
<p>按照我的理解，即使当主服务器被认为下线了，实际上仍然有<code>sentinel</code>并不觉得它已主观下线。只要半数以上的<code>sentinel</code>认为它已经主观下线，那么这个主服务器其实已经没有当主服务器的必要了，于是可以对它进行故障转移。 </p>
<h3 id="选举领头sentinel"><a href="#选举领头sentinel" class="headerlink" title="选举领头sentinel"></a>选举领头<code>sentinel</code></h3><p>只要一个<code>Sentinel</code>发现某个主服务器进入了客观下线状态，监视这个下线主服务器的各个<code>sentinel</code>会进行协商，选举领头<code>sentinel</code>，由其对失效的主服务器执行自动故障迁移操作。 </p>
<blockquote>
<p>每次领头<code>sentinel</code>选举，无论成功与否，配置纪元都会自增一次。局部领头(每个<code>sentinel</code>都会要求其他<code>sentinel</code>将自己设为局部领头，采取先到先得规则)一旦设置，配置纪元里不能再更改。只有获得半数以上的局部领头，才能真正成为真正的领头。 </p>
</blockquote>
<h3 id="故障转移-failover"><a href="#故障转移-failover" class="headerlink" title="故障转移 (failover)"></a>故障转移 (<code>failover</code>)</h3><p>领头<code>sentinel</code>需要对已下线的主服务器执行故障转移： </p>
<ul>
<li><p>从从服务器中挑选一个转换为主服务器 </p>
</li>
<li><p>让已下线主服务器属下的从服务器改为复制新的主服务器 </p>
</li>
<li><p>将已下线主服务器设置为新主服务器的从服务器 </p>
</li>
</ul>
<blockquote>
<p>在升级从服务器时，领头<code>sentinel</code>会以<code>1s</code>的频率发送<code>INFO</code>命令 </p>
</blockquote>
<p>当以前的主服务器上线之后，<code>Leader</code>会向其发送<code>SLAVEOF</code>命令，使其复制新<code>master</code>的数据。(因为需要更改实例中的<code>masterport</code>之类的参数)</p>
<p><code>Sentinel</code>集群运行过程中故障转移完成，所有<code>Sentinel</code>又会恢复平等。<code>Leader</code>仅仅是故障转移操作出现的角色。</p>
<p><code>Leader</code>并不会把自己成为<code>Leader</code>的消息发给其他<code>Sentinel</code>。其他<code>Sentinel</code>等待<code>Leader</code>从<code>slave</code>选出<code>master</code>后，检测到新的<code>master</code>正常工作后，就会去掉客观下线的标识，从而不需要进入故障转移流程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuyinzi.github.io/2019/04/15/《Redis设计与实现》读书笔记-第三-四部分/" data-id="cjujm2zk50000q68z7gkqx5k9" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/">Redis</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-TCP学习记录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/14/TCP学习记录/" class="article-date">
  <time datetime="2019-04-14T08:25:53.000Z" itemprop="datePublished">2019-04-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web/">Web</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/14/TCP学习记录/">TCP学习记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>网络模型可以概括为五层结构：</p>
<ul>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>链路层</li>
<li>物理层</li>
</ul>
<p>其中<code>TCP</code>位于传输层，主要用于保证通信的完整性及可靠性。</p>
        
          <p class="article-more-link">
            <a href="/2019/04/14/TCP学习记录/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuyinzi.github.io/2019/04/14/TCP学习记录/" data-id="cjujlwkl80011g28zdyny2a9v" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/">web</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-《Redis设计与实现》读书笔记-第二部分" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/12/《Redis设计与实现》读书笔记-第二部分/" class="article-date">
  <time datetime="2019-04-12T12:43:13.000Z" itemprop="datePublished">2019-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/12/《Redis设计与实现》读书笔记-第二部分/">《Redis设计与实现》读书笔记 第二部分</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>第二部分主要解决下面的问题：</p>
<ul>
<li>数据库在服务器中是如何保存的</li>
<li>过期键是如何保存的以及如何被清理的</li>
<li><code>RDB</code>与<code>AOF</code>的原理，以及<code>AOF</code>的重写</li>
<li><code>redis</code>是如何实现单线程下的事件驱动的</li>
<li><code>redis</code>客户端是如何保存的，有哪些属性，在什么情况下会被关闭</li>
<li>当接收到一个请求时，<code>redis</code>服务器是如何处理的</li>
<li><code>serverCron</code>是如何管理服务器资源的</li>
<li><code>redis</code>服务器是如何启动及初始化的</li>
</ul>
        
          <p class="article-more-link">
            <a href="/2019/04/12/《Redis设计与实现》读书笔记-第二部分/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuyinzi.github.io/2019/04/12/《Redis设计与实现》读书笔记-第二部分/" data-id="cjujlwklb0013g28zu9abf8hu" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/">Redis</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-常用排序算法的Python实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/12/常用排序算法的Python实现/" class="article-date">
  <time datetime="2019-04-12T08:57:30.000Z" itemprop="datePublished">2019-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/算法/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/12/常用排序算法的Python实现/">常用排序算法的Python实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>使用<code>python</code>实现冒泡排序，插入排序，选择排序，希尔排序，归并排序，快速排序和堆排序。</p>
        
          <p class="article-more-link">
            <a href="/2019/04/12/常用排序算法的Python实现/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuyinzi.github.io/2019/04/12/常用排序算法的Python实现/" data-id="cjujlwkj70001g28zis35y6f5" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Django源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/11/Django源码分析/" class="article-date">
  <time datetime="2019-04-11T05:41:00.000Z" itemprop="datePublished">2019-04-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/11/Django源码分析/">Django源码分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>分析了运行<code>python manage.py runserver</code>后所发生的事。<br>
        
          </p><p class="article-more-link">
            <a href="/2019/04/11/Django源码分析/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuyinzi.github.io/2019/04/11/Django源码分析/" data-id="cjujlwkk8000dg28zoo4bvs85" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Django/">Django</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Python拾遗-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/10/Python拾遗-2/" class="article-date">
  <time datetime="2019-04-10T08:03:16.000Z" itemprop="datePublished">2019-04-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/10/Python拾遗-2/">Python拾遗(2)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>包括<code>Python</code>中的常用数据类型。<br>
        
          </p><p class="article-more-link">
            <a href="/2019/04/10/Python拾遗-2/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuyinzi.github.io/2019/04/10/Python拾遗-2/" data-id="cjujlwkka000gg28z29jwycj0" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Python拾遗-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/10/Python拾遗-1/" class="article-date">
  <time datetime="2019-04-10T07:46:27.000Z" itemprop="datePublished">2019-04-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/10/Python拾遗-1/">Python拾遗(1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>读《<code>Python</code>源码分析》的一些记录。<br>
        
          </p><p class="article-more-link">
            <a href="/2019/04/10/Python拾遗-1/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuyinzi.github.io/2019/04/10/Python拾遗-1/" data-id="cjujlwkkc000hg28zc1ru9p9a" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-《Redis设计与实现》读书笔记-第一部分" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/10/《Redis设计与实现》读书笔记-第一部分/" class="article-date">
  <time datetime="2019-04-10T06:05:33.000Z" itemprop="datePublished">2019-04-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/10/《Redis设计与实现》读书笔记-第一部分/">《Redis设计与实现》读书笔记 第一部分</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>第一部分从第二章到第八章，主要解决下面几个问题：</p>
<ul>
<li><code>redis</code>的底层是由哪些数据结构实现的，它们的应用场景又是什么</li>
<li><code>redis</code>的五大对象分别用了哪些数据结构实现</li>
<li><code>redis</code>的内存回收机制</li>
</ul>
        
          <p class="article-more-link">
            <a href="/2019/04/10/《Redis设计与实现》读书笔记-第一部分/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuyinzi.github.io/2019/04/10/《Redis设计与实现》读书笔记-第一部分/" data-id="cjujlwkke000jg28zu24gynwx" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/">Redis</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Python线程-进程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/03/Python线程-进程/" class="article-date">
  <time datetime="2019-04-03T09:02:50.000Z" itemprop="datePublished">2019-04-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/03/Python线程-进程/">Python线程/进程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a><code>GIL</code></h2><p><code>GIL</code>:<code>global interpreter lock</code>全局锁<br>限制：使得<code>python</code>中一个线程对应于<code>C</code>语言中的一个线程。同一时刻只有一个线程运行在一个<code>CPU</code>上执行字节码，无法将多线程运行到多<code>CPU</code>上。<br>释放：根据字节码执行行数或者时间片来释放锁，或者遇到<code>io</code>操作时会主动释放。<br>显示字节码：<code>from dis import dis</code></p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li>耗<code>CPU</code>操作(例如运算)采用多进程更加具有优势(<code>GIL</code>使得多线程没有办法在不同的<code>CPU</code>上运行)</li>
<li>耗<code>IO</code>操作采用多线程更具有优势(当碰见<code>IO</code>操作时，会主动释放<code>GIL</code>)</li>
</ul>
        
          <p class="article-more-link">
            <a href="/2019/04/03/Python线程-进程/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuyinzi.github.io/2019/04/03/Python线程-进程/" data-id="cjujlwkl50010g28zvsxbbah7" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页&raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    
  <div class="widget-wrap">
     
        <h3 class="follow-title ">About me</h3>
     
    <div class="widget follow">
      
              <a class="github" aria-hidden="true" href="https://github.com/Yuyinzi" target="_blank" title="Github"></a>
      
      
      
      
    </div>
  </div>


  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title categories">分类</h3>
    <div class="widget" id="categories">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工作之外/">工作之外</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title tagcloud">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Django/" style="font-size: 17.67px;">Django</a> <a href="/tags/Python/" style="font-size: 25px;">Python</a> <a href="/tags/Redis/" style="font-size: 21.33px;">Redis</a> <a href="/tags/web/" style="font-size: 14px;">web</a> <a href="/tags/算法/" style="font-size: 14px;">算法</a> <a href="/tags/随笔/" style="font-size: 14px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/04/16/Django笔记/">Django笔记</a>
          </li>
        
          <li>
            <a href="/2019/04/15/《Redis设计与实现》读书笔记-第三-四部分/">《Redis设计与实现》读书笔记 第三/四部分</a>
          </li>
        
          <li>
            <a href="/2019/04/14/TCP学习记录/">TCP学习记录</a>
          </li>
        
          <li>
            <a href="/2019/04/12/《Redis设计与实现》读书笔记-第二部分/">《Redis设计与实现》读书笔记 第二部分</a>
          </li>
        
          <li>
            <a href="/2019/04/12/常用排序算法的Python实现/">常用排序算法的Python实现</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title archive">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">11</span></li></ul>
    </div>
  </div>


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2019 Littlemay&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;littlemay2015@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png">
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->



 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>