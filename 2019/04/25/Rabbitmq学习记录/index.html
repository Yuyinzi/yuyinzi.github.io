<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Rabbitmq学习记录 | Yuyinzi&#39;s note</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="优点 实现了AMQP标准的消息服务器 可靠性，使用持久化、传输确认、发布确认等保证 灵活的路由 集群部署简单 支持多种协议，以及多种语言客户端 易用的用户界面  …">
<meta name="keywords" content="Python,Rabbitmq">
<meta property="og:type" content="article">
<meta property="og:title" content="Rabbitmq学习记录">
<meta property="og:url" content="http://yuyinzi.github.io/2019/04/25/Rabbitmq学习记录/index.html">
<meta property="og:site_name" content="Yuyinzi&#39;s note">
<meta property="og:description" content="优点 实现了AMQP标准的消息服务器 可靠性，使用持久化、传输确认、发布确认等保证 灵活的路由 集群部署简单 支持多种协议，以及多种语言客户端 易用的用户界面  …">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yuyinzi.github.io/assets/rpc.jpg">
<meta property="og:updated_time" content="2019-04-26T09:11:23.925Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Rabbitmq学习记录">
<meta name="twitter:description" content="优点 实现了AMQP标准的消息服务器 可靠性，使用持久化、传输确认、发布确认等保证 灵活的路由 集群部署简单 支持多种协议，以及多种语言客户端 易用的用户界面  …">
<meta name="twitter:image" content="http://yuyinzi.github.io/assets/rpc.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Yuyinzi&#39;s note" type="application/atom+xml">
  
  
    <link rel="icon" href="/may.jpeg">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yuyinzi.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Yuyinzi&#39;s note</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Rabbitmq学习记录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/25/Rabbitmq学习记录/" class="article-date">
  <time datetime="2019-04-25T07:28:17.000Z" itemprop="datePublished">2019-04-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MQ/">MQ</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Rabbitmq学习记录
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>实现了<code>AMQP</code>标准的消息服务器</li>
<li>可靠性，使用持久化、传输确认、发布确认等保证</li>
<li>灵活的路由</li>
<li>集群部署简单</li>
<li>支持多种协议，以及多种语言客户端</li>
<li>易用的用户界面</li>
</ul>
<p>…</p>
<a id="more"></a>
<h2 id="MAC下的安装"><a href="#MAC下的安装" class="headerlink" title="MAC下的安装"></a><code>MAC</code>下的安装</h2><p>采用<code>Homebrew</code>进行安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ brew update</span><br><span class="line">➜  ~ brew install rabbitmq</span><br></pre></td></tr></table></figure>
<p>通过<code>brew</code>安装的文件位于<code>/usr/local/Cellar/rabbitmq/3.7.14/sbin</code>中。开启插件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  /usr/local/Cellar/rabbitmq/3.7.14 sudo sbin/rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>
<p>直接运行<code>rabbitmq-server</code>会提示找不到命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ rabbitmq-server</span><br><span class="line">zsh: command not found: rabbitmq-server</span><br></pre></td></tr></table></figure>
<p>因为使用的是<code>zsh</code>，所以需要将路径添加至<code>.zshrc</code>中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ cat .zshrc</span><br><span class="line"><span class="meta">#</span> If you come from bash you might have to change your $PATH.</span><br><span class="line"><span class="meta">#</span> export PATH=$HOME/bin:/usr/local/bin:$PATH</span><br><span class="line"><span class="meta">#</span> Path to your oh-my-zsh installation.</span><br><span class="line">export PATH=$PATH:/usr/local/opt/rabbitmq/sbin</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>再<code>source .zshrc</code>使它生效。这下<code>rabbit-server</code>是有用了，但是启动却报错了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-04-25 15:18:09.525358</span><br><span class="line">    args: []</span><br><span class="line">    format: "Error when reading /Users/littlemay/.erlang.cookie: eacces"</span><br><span class="line">    label: &#123;error_logger,error_msg&#125;</span><br></pre></td></tr></table></figure>
<p>原因是<code>/Users/littlemay/.erlang.cookie</code>这个文件没有权限，需要更改文件所有者以及权限：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ls -l /Users/littlemay/.erlang.cookie</span><br><span class="line">-r--------  1 root  staff  20  4 25 00:00 /Users/littlemay/.erlang.cookie</span><br><span class="line">➜  ~ sudo chown littlemay:staff /Users/littlemay/.erlang.cookie</span><br><span class="line">➜  ~ sudo chmod u+x /Users/littlemay/.erlang.cookie</span><br></pre></td></tr></table></figure>
<p>折腾了半个小时，此时终于可以不使用<code>sudo</code>启动了。</p>
<p>可以使用<code>rabbitmqctl start_app/stop_app</code>启动/停止<code>rabbitmq</code>。网页端的用户界面访问：<code>localhost:15762</code>，默认用户名密码都为<code>guest</code>。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><code>Message</code>：消息，<code>AMQP</code>中预定了<code>14</code>个属性，即后文<code>pika</code>中会用到的<code>BasicProperties</code></li>
<li><code>Producer</code>：消息的生产者，也是一个向交换机发布消息的客户端应用程序</li>
<li><code>Consumer</code>：消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</li>
<li><code>Exchange</code>：交换机，用来接收生产者发送的消息并根据规则将这些消息路由给服务器中的队列</li>
<li><code>Queue</code>：消息队列，用来保存消息直到发送给消费者。一个消息可投入一个或多个队列。如果一个队列没有被任何消费者队列，那么它将一直在队列里面，等待消费者连接到这个队列将其取走。多个消费者可以订阅同一个队列，此时队列的消息会被<strong>平均分摊</strong>(<code>round-robin</code>)给多个消费者处理。</li>
<li><code>Binding</code>：绑定，将<code>Exchange</code>和<code>Queue</code>按照路由规则绑定</li>
<li><code>Channel</code>：信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的<code>TCP</code>连接内的虚拟连接，<code>AMQP</code> 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁<code>TCP</code>都是非常昂贵的开销，所以引入了信道的概念，以复用一条<code>TCP</code>连接</li>
<li><code>Virtual Host</code>：虚拟主机，用作不同用户的权限分离。默认的<code>vhost</code>是<code>/</code>。</li>
<li><code>Broker</code>：表示消息队列服务器实体</li>
</ul>
<h3 id="Routing-Key与Binding-Key"><a href="#Routing-Key与Binding-Key" class="headerlink" title="Routing Key与Binding Key"></a><code>Routing Key</code>与<code>Binding Key</code></h3><p><code>Binding Key</code>是在<code>Exchange</code>与<code>Queue</code>进行<code>Binding</code>时使用的路由规则。多个<code>Queue</code>允许使用同一个<code>Binding Key</code>与<code>Exchange</code>进行绑定。</p>
<p><code>Routing Key</code>是当生产者将消息发送给<code>Exchange</code>时，指定的路由规则。它会依据<code>Exchange Type</code>及<code>Binding Key</code>联合使用来决定将消息投放到哪个队列中。</p>
<blockquote>
<p><code>Routing Key</code>的长度限制为<code>255 bytes</code>。</p>
</blockquote>
<h3 id="Exchange-Types"><a href="#Exchange-Types" class="headerlink" title="Exchange Types"></a><code>Exchange Types</code></h3><p>通常使用的有四种：</p>
<ul>
<li><code>fanout</code>：将所有发送到该<code>Exchange</code>的消息路由到所有与它绑定的<code>Queue</code>中，此时<code>Binding Key</code>与<code>Routing Key</code>不起作用</li>
<li><code>direct</code>：将所有发送到该<code>Exchange</code>的消息路由到<code>Binding Key</code>与<code>Routing Key</code>完全匹配的<code>Queue</code>中</li>
<li><code>topic</code>：将所有发送到该<code>Exchange</code>的消息路由到<code>Binding Key</code>与<code>Routing Key</code>相匹配的<code>Queue</code>中。采用<code>.</code>进行分隔(每分隔开的一段独立字符串成为一个单词)，<code>*</code>表示匹配一个单词，<code>#</code>表示匹配<code>0</code>个或者多个。</li>
<li><code>headers</code>：不依赖于<code>Routing Key</code>与<code>Bingding Key</code>的匹配规则路由消息，而是根据发送消息内容中的<code>headers</code>属性进行匹配，它与<code>direct</code>功能一致，但是性能十分低，一般不使用。</li>
</ul>
<h3 id="Message-Acknowledgment"><a href="#Message-Acknowledgment" class="headerlink" title="Message Acknowledgment"></a><code>Message Acknowledgment</code></h3><p>消费者接收到了消息，<code>RabbitMQ</code>并不会立即将消息从队列中丢弃，而是在接收到消费者的<code>ACK</code>响应之后，才进行丢弃。</p>
<p>如果<code>RabbitMQ</code>没有收到回执并检测到消费者的<code>RabbitMQ</code>断开，将会传递给其他消费者直到队列接收到了<code>ACK</code>，以此保证每一个消息都能被有效传递。因此，如果忘记回复<code>ACK</code>，那么队列中的消息会越来越多，<code>RabbitMQ server</code>不会再发送数据给它，可以起到限流的作用。</p>
<p><code>Prefetch Count</code></p>
<p>允许消费者每次从队列中获取任意数量的消息。针对任务粒度小，执行时间短的消费者，可以设定更大的预读取数。</p>
<p><code>RPC</code>远过程调用</p>
<p>除了异步通信之外，<code>RabbitMQ</code>也支持同步调用。实现原理如图：</p>
<p><img src="/assets/rpc.jpg" alt="RPC调用"></p>
<ol>
<li>生产者在生产请求消息时，会在请求消息的属性中设置两个<code>replyTo</code> 值：一个为<code>Queue Name</code>，用于告知消费者将处理完成后的通知消息返回到该队列；另一个为<code>correlationId</code>，是请求消息的唯一标示，随着请求消息一同发送给消费者，也会随着响应消息返回给生产者，生产者就能够通过<code>correlationId</code>来判定来判定请求是否被成功执行，最终实现请求和响应的一一配对。</li>
<li>生产者只有在接收到响应消息之后才会继续发生下一次请求消息，以此实现同步的效果</li>
</ol>
<h2 id="Python3实践"><a href="#Python3实践" class="headerlink" title="Python3实践"></a><code>Python3</code>实践</h2><p>首先需要安装<code>pika</code>，分别建立消费者和生产者：</p>
<p><strong>生产者</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbit_p.py</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">'localhost'</span>))</span><br><span class="line"></span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue=<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    body = <span class="string">'%s Hello rabbitmq'</span> % i</span><br><span class="line">    channel.basic_publish(exchange=<span class="string">''</span>,</span><br><span class="line">                          routing_key=<span class="string">'hello'</span>,</span><br><span class="line">                          body=body)</span><br><span class="line"></span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>
<p><strong>消费者</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbit_c1.py</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"><span class="comment"># 为了防止queue不存在，最好消费者和生产者都创建</span></span><br><span class="line">channel.queue_declare(queue=<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    print(body)</span><br><span class="line"><span class="comment"># 如果不开启ack，消息会一直显示unacked，每当消费者重启又会重复消费</span></span><br><span class="line">channel.basic_consume(on_message_callback=callback,</span><br><span class="line">                       queue=<span class="string">'hello'</span>,</span><br><span class="line">                     auto_ack=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用<code>basic_consume</code>而不是循环调用<code>basic_get</code></p>
</blockquote>
<p>如果使用<code>exchange=&#39;&#39;</code>，会绑定在<code>RabbitMQ</code>默认的<code>Exchange</code>下，它绑定了所有的<code>queue</code>，<code>routing key</code>使用<code>queue name</code>。</p>
<p>如果再开启一个消费者，那么他们会轮流处理消息。</p>
<h3 id="prefetch-count"><a href="#prefetch-count" class="headerlink" title="prefetch_count"></a><code>prefetch_count</code></h3><p>为了防止有的消费者空闲，所以可以设置<code>prefetch_count</code>参数(使用<code>basic_qos</code>来指定)，当<code>RabbitMQ</code>发现有个消费者迟迟没有返回<code>ACK</code>，便不会再将消息分配给它，此时需要我们采用主动<code>ACK</code>的方式，消费者<code>1</code>不进行<code>ack</code>，消费者<code>2</code>进行<code>ack</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbit_c1.py</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    print(body)</span><br><span class="line"><span class="comment"># basic_qos需要放在basic_consume前才有效</span></span><br><span class="line">channel.basic_qos(prefetch_count=<span class="number">3</span>)</span><br><span class="line">channel.basic_consume(on_message_callback=callback,</span><br><span class="line">                       queue=<span class="string">'hello'</span>,</span><br><span class="line">                      )</span><br><span class="line">...</span><br><span class="line"><span class="comment"># rabbit_c2.py</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    print(body)</span><br><span class="line">    <span class="comment"># 主动使用ack告知调用方</span></span><br><span class="line">    ch.basic_ack(delivery_tag=method.delivery_tag)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以发现，消费者<code>1</code>只处理了三条数据(并且网页端显示一直是<code>unacked</code>)，其他的数据都由消费者<code>2</code>处理了。接着此时关闭消费者<code>1</code>，会发现这三条数据又被分配给消费者<code>2</code>所处理了。</p>
<h3 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a><code>Exchange</code></h3><p><strong>fanout</strong>类型：</p>
<p>需要在消费者和生产者上面都加上对<code>exchange</code>的声明，两个消费者分别订阅了<code>hello1</code>与<code>hello2</code>队列，这两个队列都连向<code>hello_fanout</code>这个<code>exchange</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbit_c1.py</span></span><br><span class="line">...</span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'hello_fanout'</span>, exchange_type=<span class="string">'fanout'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'hello1'</span>)</span><br><span class="line">channel.queue_bind(exchange=<span class="string">'hello_fanout'</span>, queue=<span class="string">'hello1'</span>, routing_key=<span class="string">'hello.1'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="comment"># rabbit_c2.py </span></span><br><span class="line">...</span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'hello_fanout'</span>, exchange_type=<span class="string">'fanout'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'hello2'</span>)</span><br><span class="line">channel.queue_bind(exchange=<span class="string">'hello_fanout'</span>, queue=<span class="string">'hello1'</span>, routing_key=<span class="string">'hello.2'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="comment"># rabbit_p.py</span></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'hello_fanout'</span>, exchange_type=<span class="string">'fanout'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'hello1'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'hello2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    body = <span class="string">'%s Hello rabbitmq'</span> % i</span><br><span class="line">    channel.basic_publish(exchange=<span class="string">'hello_fanout'</span>,</span><br><span class="line">                          routing_key=<span class="string">'world'</span>,</span><br><span class="line">                          body=body)</span><br></pre></td></tr></table></figure>
<p>在<code>fanout</code>模式下，<code>routing_key</code>即使不匹配也没有关系。消费者<code>1</code>和消费者<code>2</code>的输出结果一样。</p>
<p><strong>direct</strong></p>
<p>将消费者修改为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbit_c1.py</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># 修改exchange的type为direct</span></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'hello_direct'</span>, exchange_type=<span class="string">'direct'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'hello1'</span>)</span><br><span class="line"><span class="comment"># 指定路由规则</span></span><br><span class="line">channel.queue_bind(exchange=<span class="string">'hello_direct'</span>, queue=<span class="string">'hello1'</span>, routing_key=<span class="string">'hello.1'</span>)</span><br><span class="line">...</span><br><span class="line">channel.basic_consume(on_message_callback=callback,</span><br><span class="line">                       queue=<span class="string">'hello1'</span>,</span><br><span class="line">                      )</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>生产者：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbit_p.y</span></span><br><span class="line">...</span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'hello'</span>, exchange_type=<span class="string">'direct'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'hello1'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'hello2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    body = <span class="string">'%s Hello rabbitmq'</span> % i</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">10</span>:</span><br><span class="line">        channel.basic_publish(exchange=<span class="string">'hello'</span>,</span><br><span class="line">                              routing_key=<span class="string">'hello.1'</span>,</span><br><span class="line">                              body=body)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        channel.basic_publish(exchange=<span class="string">'hello'</span>,</span><br><span class="line">                              routing_key=<span class="string">'hello.2'</span>,</span><br><span class="line">                              body=body)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>此时<code>i&lt;10</code>的消息会由消费者<code>1</code>处理。</p>
<p><strong>topic</strong></p>
<p><code>Binding Key</code>可以存在<code>*</code>与<code>#</code>，但是生产者的<code>Routing Key</code>应当是精确的。修改消费者与生产者分别为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#rabbit_c1.py</span></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'hello_topic'</span>, exchange_type=<span class="string">'topic'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'hello1'</span>)</span><br><span class="line">channel.queue_bind(exchange=<span class="string">'hello_topic'</span>, queue=<span class="string">'hello1'</span>, routing_key=<span class="string">'hello.*'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="comment">#rabbit_c2.py 绑定了两种规则</span></span><br><span class="line">channel.queue_bind(exchange=<span class="string">'hello_topic'</span>, queue=<span class="string">'hello2'</span>, routing_key=<span class="string">'hello.*'</span>)</span><br><span class="line">channel.queue_bind(exchange=<span class="string">'hello_topic'</span>, queue=<span class="string">'hello2'</span>, routing_key=<span class="string">'*.hello.*'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#rabbit_p.py</span></span><br><span class="line">...</span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'hello_topic'</span>, exchange_type=<span class="string">'topic'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    body = <span class="string">'%s Hello rabbitmq'</span> % i</span><br><span class="line">    <span class="keyword">if</span> <span class="number">10</span> &lt; i &lt; <span class="number">20</span>:</span><br><span class="line">        channel.basic_publish(exchange=<span class="string">'hello_topic'</span>,</span><br><span class="line">                              routing_key=<span class="string">'hello.2'</span>,</span><br><span class="line">                              body=body)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        channel.basic_publish(exchange=<span class="string">'hello_topic'</span>,</span><br><span class="line">                              routing_key=<span class="string">'2.hello.2'</span>,</span><br><span class="line">                              body=body)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>一个队列可以使用多种路由规则与同一<code>exchange</code>绑定。此时消费者<code>2</code>可以收到全部消息，而消费者<code>1</code>只能收到<code>11-19</code>之间的消息。</p>
<p>同样的，一个队列可以与多个<code>exchange</code>绑定，让消费者<code>2</code>订阅的队列同时与<code>hello_topic</code>和<code>hello_direct</code>相连：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbit_c2.py</span></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'hello_topic'</span>, exchange_type=<span class="string">'topic'</span>)</span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'hello_direct'</span>, exchange_type=<span class="string">'direct'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'hello2'</span>)</span><br><span class="line">channel.queue_bind(exchange=<span class="string">'hello_direct'</span>, queue=<span class="string">'hello2'</span>, routing_key=<span class="string">'hello.2'</span>)</span><br><span class="line">channel.queue_bind(exchange=<span class="string">'hello_topic'</span>, queue=<span class="string">'hello2'</span>, routing_key=<span class="string">'hello.*'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># rabbit_p.py</span></span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'hello_topic'</span>, exchange_type=<span class="string">'topic'</span>)</span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'hello_direct'</span>, exchange_type=<span class="string">'direct'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    body = <span class="string">'%s Hello rabbitmq'</span> % i</span><br><span class="line">    <span class="keyword">if</span> <span class="number">10</span> &lt; i &lt; <span class="number">20</span>:</span><br><span class="line">        channel.basic_publish(exchange=<span class="string">'hello_topic'</span>,</span><br><span class="line">                              routing_key=<span class="string">'hello.1'</span>,</span><br><span class="line">                              body=body)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        channel.basic_publish(exchange=<span class="string">'hello_direct'</span>,</span><br><span class="line">                              routing_key=<span class="string">'hello.2'</span>,</span><br><span class="line">                              body=body)</span><br></pre></td></tr></table></figure>
<p>此时，消费者<code>2</code>可以收到全部消息。</p>
<h3 id="exclusive"><a href="#exclusive" class="headerlink" title="exclusive"></a><code>exclusive</code></h3><p>前面测试的时候，如果不重启<code>RabbitServer</code>，如果没有删除交换机或者队列的话，以前的路由规则仍然存在，经常会出现匪夷所思的问题。这是因为持久化的问题，留到下节介绍。</p>
<p>实际上可以使用临时队列的方式进行处理，<code>exclusive</code>参数指明这个队列为排他性队列，即只有自己可以访问，此时生产者不能再进行生命，当连接断掉，这个<code>queue</code>会被删除(这点与<code>auto_delete</code>参数功能一致)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbit_c3.py</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'hello_direct'</span>, exchange_type=<span class="string">'direct'</span>)</span><br><span class="line"><span class="comment"># 如果queue为空，会自动创建一个名字唯一的队列，想要连接断开自动删除，可以使用exclusive，也可以使用auto_delete</span></span><br><span class="line"><span class="comment"># 队列名采用r.method.queue获取</span></span><br><span class="line">r = channel.queue_declare(queue=<span class="string">''</span>, exclusive=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#r = channel.queue_declare(queue='', auto_delete=True)</span></span><br><span class="line">channel.queue_bind(exchange=<span class="string">'hello_direct'</span>, queue=r.method.queue, routing_key=<span class="string">'hello.2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    print(body)</span><br><span class="line">    ch.basic_ack(delivery_tag=method.delivery_tag)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(on_message_callback=callback,</span><br><span class="line">                       queue=r.method.queue)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
<p>这样可以实现一个动态创建队列的消费者。</p>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>当将<code>RabbitMQ</code>停掉，会发现不论是<code>exchange</code>还是<code>queue</code>的所有信息都丢失了，因此如果需要恢复<code>exchange</code>和<code>queue</code>，需要在声明交换机和队列时就提供持久化参数(<code>durable=True</code>)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbit_c1.py</span></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'hello_topic'</span>, exchange_type=<span class="string">'topic'</span>, durable=<span class="literal">True</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">'hello1'</span>, durable=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果消费者声明了<code>durable=True</code>，那么生产者在再次声明时，也必须将其声明为<code>durable=True</code>，否则会报错。或者也可以删除后再次声明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.queue_delete(queue=<span class="string">'hello1'</span>)</span><br><span class="line">channel.exchange_delete(exchange=<span class="string">'hello_topic'</span>)</span><br></pre></td></tr></table></figure>
<p>但是想要使得队列里的消息不丢失，需要额外在<code>basic_publish</code>时也指定消息的参数(<code>delivery_mode=2</code>)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbit_p.py</span></span><br><span class="line">channel.basic_publish(exchange=<span class="string">'hello_topic'</span>,</span><br><span class="line">                      routing_key=<span class="string">'hello.1'</span>,</span><br><span class="line">                      properties=pika.BasicProperties(delivery_mode=<span class="number">2</span>),</span><br><span class="line">                      body=body)</span><br></pre></td></tr></table></figure>
<p>这样从交换机、队列层面保证了消息只要进入了，就不会丢失，但是如果在投递的过程中丢失，比如消息并未到达交换机或者没有对应的队列(消息会被丢弃)，此时应当使用<code>RabbitMQ</code>提供的<code>confirm mode</code>。</p>
<p>以上测试是在最新的<code>pika==1.0.1</code>之下，但是这个版本下<code>channel.basic_publish</code>并没有返回了，所以切回<code>pika=0.13.1</code>下测试，接下来的环境都为<code>Python=3.7 pika=0.13.1</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbit_p.py</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">'localhost'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'test'</span>, exchange_type=<span class="string">'fanout'</span>)</span><br><span class="line">channel.queue_declare(queue=<span class="string">"test"</span>, durable=<span class="literal">True</span>, exclusive=<span class="literal">False</span>, auto_delete=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启确认</span></span><br><span class="line">channel.confirm_delivery()</span><br><span class="line">res = channel.basic_publish(exchange=<span class="string">'test'</span>,</span><br><span class="line">                         routing_key=<span class="string">'test'</span>,</span><br><span class="line">                         body=<span class="string">'Hello World!'</span>,</span><br><span class="line">                         properties=pika.BasicProperties(content_type=<span class="string">'text/plain'</span>,</span><br><span class="line">                                                         delivery_mode=<span class="number">2</span>),</span><br><span class="line">                            mandatory=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>此时由于没有消费者绑定名为<code>test</code>的<code>exchange</code>，因此会返回<code>False</code>。</p>
<blockquote>
<p>每一个版本的<code>pika</code>函数参数都有很大不同T_T</p>
</blockquote>
<p><code>confirm mode</code>的确认结果表示，一条<code>persisting</code>的消息投向<code>durable</code>队列成功，并且成功写到磁盘。</p>
<h3 id="basic-reject"><a href="#basic-reject" class="headerlink" title="basic_reject"></a><code>basic_reject</code></h3><p>与<code>basic_ack</code>相对应的是<code>basic_reject</code>，它可以拒绝一条消息，如果要拒绝多条消息，使用<code>basic_nack</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rabbit_c1.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    <span class="keyword">if</span> count % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        ch.basic_reject(delivery_tag=method.delivery_tag)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(body)</span><br><span class="line">        ch.basic_ack(delivery_tag=method.delivery_tag)</span><br><span class="line">    count += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>requeue=True</code>，表示消息被拒绝后可以由其他消费者处理。</p>
<h3 id="RPC调用"><a href="#RPC调用" class="headerlink" title="RPC调用"></a><code>RPC</code>调用</h3><p>首先定义生产者端：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line">conn = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">ch = conn.channel()</span><br><span class="line">ch.exchange_declare(exchange=<span class="string">'rpc_p'</span>, exchange_type=<span class="string">'fanout'</span>)</span><br><span class="line">ch.exchange_declare(exchange=<span class="string">'rpc_r'</span>, exchange_type=<span class="string">'direct'</span>)</span><br><span class="line">ch.queue_declare(queue=<span class="string">'rpc_p'</span>)</span><br><span class="line">ch.queue_declare(queue=<span class="string">'rpc_r'</span>)</span><br><span class="line">ch.queue_bind(exchange=<span class="string">'rpc_p'</span>, queue=<span class="string">'rpc_p'</span>)</span><br><span class="line">ch.queue_bind(exchange=<span class="string">'rpc_r'</span>, queue=<span class="string">'rpc_r'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(channel, method, properties, body)</span>:</span></span><br><span class="line">    print(body, properties.correlation_id)</span><br><span class="line">    channel.basic_ack(delivery_tag=method.delivery_tag)</span><br><span class="line"></span><br><span class="line">ch.basic_consume(callback, queue=<span class="string">'rpc_r'</span>)</span><br><span class="line">correlation_id = uuid.uuid4().hex</span><br><span class="line">print(correlation_id)</span><br><span class="line">ch.basic_publish(exchange=<span class="string">'rpc_p'</span>,</span><br><span class="line">                 routing_key=<span class="string">''</span>,</span><br><span class="line">                 body=<span class="string">'1,2,3,4'</span>,</span><br><span class="line">                 properties=pika.BasicProperties(</span><br><span class="line">                     reply_to=<span class="string">'rpc_r'</span>,</span><br><span class="line">                     correlation_id=correlation_id</span><br><span class="line">                 ))</span><br><span class="line">ch.start_consuming()</span><br></pre></td></tr></table></figure>
<p>生产者指定自己发出消息的交换机为<code>rpc_p</code>，需要接受回复使用的交换机为<code>rpc_r</code>，并分别绑定队列<code>rpc_p</code>和<code>rpc_r</code>，在发布消息时，指定<code>reply_to</code>参数以及标识这条消息的唯一<code>id</code>。</p>
<p>消费者：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">conn = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>))</span><br><span class="line">ch = conn.channel()</span><br><span class="line">ch.exchange_declare(exchange=<span class="string">'rpc_r'</span>, exchange_type=<span class="string">'direct'</span>)</span><br><span class="line">ch.exchange_declare(exchange=<span class="string">'rpc_p'</span>, exchange_type=<span class="string">'fanout'</span>)</span><br><span class="line">ch.queue_declare(queue=<span class="string">'rpc_p'</span>)</span><br><span class="line">ch.queue_bind(exchange=<span class="string">'rpc_p'</span>, queue=<span class="string">'rpc_p'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(channel, method, properties, body)</span>:</span></span><br><span class="line">    print(body)</span><br><span class="line">    body = body.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    s = sum(int(x) <span class="keyword">for</span> x <span class="keyword">in</span> body.split(<span class="string">','</span>))</span><br><span class="line">    channel.basic_publish(exchange=<span class="string">'rpc_r'</span>,</span><br><span class="line">                          routing_key=properties.reply_to,</span><br><span class="line">                          body=str(s),</span><br><span class="line">                          properties=pika.BasicProperties(</span><br><span class="line">                              correlation_id=properties.correlation_id</span><br><span class="line">                          ))</span><br><span class="line">    channel.basic_ack(delivery_tag=method.delivery_tag)</span><br><span class="line"></span><br><span class="line">ch.basic_consume(callback, queue=<span class="string">'rpc_p'</span>)</span><br><span class="line">ch.start_consuming()</span><br></pre></td></tr></table></figure>
<p>消费者只需要一直监听来自队列<code>rpc_p</code>的消息，并且在接收到消息后将确认信息发送至<code>reply_to</code>所指向的队列，同时指明自己所收到的是哪条消息。</p>
<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生产者</span></span><br><span class="line"><span class="number">7</span>bfd8db775144308945b679ed4c5a2ed</span><br><span class="line"><span class="string">b'10'</span> <span class="number">7</span>bfd8db775144308945b679ed4c5a2ed</span><br><span class="line"><span class="comment"># 消费者</span></span><br><span class="line"><span class="string">b'1,2,3,4'</span></span><br></pre></td></tr></table></figure>
<p><code>References</code>：</p>
<p><a href="https://www.zouyesheng.com/rabbitmq.html#toc11" target="_blank" rel="noopener">RabbitMQ 使用参考</a></p>
<p><a href="https://www.jianshu.com/p/79ca08116d57" target="_blank" rel="noopener">消息队列之 RabbitMQ</a></p>
<p><a href="https://my.oschina.net/wy08/blog/186202" target="_blank" rel="noopener">RabbitMq的整理 exchange、route、queue关系</a></p>
<p><a href="https://juejin.im/entry/599e5e3b5188252437799049" target="_blank" rel="noopener">一篇全面透彻的RabbitMQ指南！</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuyinzi.github.io/2019/04/25/Rabbitmq学习记录/" data-id="cjuxuu4j10013lz8z8ihpbvb1" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Rabbitmq/">Rabbitmq</a></li></ul>

    </footer>
  </div>
  
    
 <script src="/jquery/jquery.min.js"></script>
  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
  
    <a href="/2019/04/16/Django笔记/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">Django笔记</div>
    </a>
  
</nav>

  
</article>
 
   <!-- 
  <div class="comments" id="comments">
    
     
       
       
      
      
  </div>
  -->
  

</section>
           
    <aside id="sidebar">
  
    

  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#优点"><span class="toc-number">1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MAC下的安装"><span class="toc-number">2.</span> <span class="toc-text">MAC下的安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本概念"><span class="toc-number">3.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Routing-Key与Binding-Key"><span class="toc-number">3.1.</span> <span class="toc-text">Routing Key与Binding Key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exchange-Types"><span class="toc-number">3.2.</span> <span class="toc-text">Exchange Types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Message-Acknowledgment"><span class="toc-number">3.3.</span> <span class="toc-text">Message Acknowledgment</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python3实践"><span class="toc-number">4.</span> <span class="toc-text">Python3实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#prefetch-count"><span class="toc-number">4.1.</span> <span class="toc-text">prefetch_count</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exchange"><span class="toc-number">4.2.</span> <span class="toc-text">Exchange</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exclusive"><span class="toc-number">4.3.</span> <span class="toc-text">exclusive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#持久化"><span class="toc-number">4.4.</span> <span class="toc-text">持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#basic-reject"><span class="toc-number">4.5.</span> <span class="toc-text">basic_reject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RPC调用"><span class="toc-number">4.6.</span> <span class="toc-text">RPC调用</span></a></li></ol></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2019 Littlemay&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;littlemay2015@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png">
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->



 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>