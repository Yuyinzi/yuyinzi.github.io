<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Python线程/进程 | Yuyinzi&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="GILGIL:global interpreter lock全局锁限制：使得python中一个线程对应于C语言中的一个线程。同一时刻只有一个线程运行在一个CPU上执行字节码，无法将多线程运行到多CPU上。释放：根据字节码执行行数或者时间片来释放锁，或者遇到io操作时会主动释放。显示字节码：from dis import dis 区别 耗CPU操作(例如运算)采用多进程更加具有优势(GIL使得多线程">
<meta name="keywords" content="Python">
<meta property="og:type" content="article">
<meta property="og:title" content="Python线程&#x2F;进程">
<meta property="og:url" content="http://yuyinzi.github.io/2019/04/03/Python线程-进程/index.html">
<meta property="og:site_name" content="Yuyinzi&#39;s blog">
<meta property="og:description" content="GILGIL:global interpreter lock全局锁限制：使得python中一个线程对应于C语言中的一个线程。同一时刻只有一个线程运行在一个CPU上执行字节码，无法将多线程运行到多CPU上。释放：根据字节码执行行数或者时间片来释放锁，或者遇到io操作时会主动释放。显示字节码：from dis import dis 区别 耗CPU操作(例如运算)采用多进程更加具有优势(GIL使得多线程">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-04-12T07:27:42.826Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python线程&#x2F;进程">
<meta name="twitter:description" content="GILGIL:global interpreter lock全局锁限制：使得python中一个线程对应于C语言中的一个线程。同一时刻只有一个线程运行在一个CPU上执行字节码，无法将多线程运行到多CPU上。释放：根据字节码执行行数或者时间片来释放锁，或者遇到io操作时会主动释放。显示字节码：from dis import dis 区别 耗CPU操作(例如运算)采用多进程更加具有优势(GIL使得多线程">
  
    <link rel="alternate" href="/atom.xml" title="Yuyinzi&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/may.jpeg">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yuyinzi.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Yuyinzi&#39;s blog</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Python线程-进程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/03/Python线程-进程/" class="article-date">
  <time datetime="2019-04-03T09:02:50.000Z" itemprop="datePublished">2019-04-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Python线程/进程
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a><code>GIL</code></h2><p><code>GIL</code>:<code>global interpreter lock</code>全局锁<br>限制：使得<code>python</code>中一个线程对应于<code>C</code>语言中的一个线程。同一时刻只有一个线程运行在一个<code>CPU</code>上执行字节码，无法将多线程运行到多<code>CPU</code>上。<br>释放：根据字节码执行行数或者时间片来释放锁，或者遇到<code>io</code>操作时会主动释放。<br>显示字节码：<code>from dis import dis</code></p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li>耗<code>CPU</code>操作(例如运算)采用多进程更加具有优势(<code>GIL</code>使得多线程没有办法在不同的<code>CPU</code>上运行)</li>
<li>耗<code>IO</code>操作采用多线程更具有优势(当碰见<code>IO</code>操作时，会主动释放<code>GIL</code>)</li>
</ul>
<a id="more"></a>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a><code>ThreadLocal</code></h2><p>使用场景：多线程环境下，如果使用全局变量，需要加锁。但是如果每个线程都需要拥有自己的私有数据时，即这个数据对其他线程不可见。可以使用<code>ThreadLocal</code>变量，它本身是一个全局变量，但是每个线程却可以利用它来保存属于自己的私有数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">global_data = threading.local()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> threading.current_thread().getName(), global_data.num</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_cal</span><span class="params">()</span>:</span></span><br><span class="line">    global_data.num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="number">1000</span>):</span><br><span class="line">        global_data.num += <span class="number">1</span></span><br><span class="line">    show()</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    threads.append(threading.Thread(target=thread_cal))</span><br><span class="line">    threads[i].start()</span><br></pre></td></tr></table></figure></p>
<h2 id="join-和setDaemon"><a href="#join-和setDaemon" class="headerlink" title="join()和setDaemon()"></a><code>join()</code>和<code>setDaemon()</code></h2><p><code>join</code>：主线程启动若干个子线程后，可以继续执行主线程的代码，也可以等待所有子线程执行完毕后继续执行主线程。如果子线程调用了<code>join</code>方法，则表明<strong>主线程必须等子线程执行完了才可以往下继续执行</strong>。因此，如果需要所有的子线程都能再主线程结束前被执行完毕，则必须为每一个子线程都注册<code>join</code>。<br><code>setDaemon()</code>：设置此线程是否被主线程守护回收。需要在<code>start</code>方法前调用，设为<code>True</code>时，当主线程结束之后，会回收此子线程。默认是<code>False</code>，即主线程结束时不会回收子线程。</p>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><h3 id="Threading模块"><a href="#Threading模块" class="headerlink" title="Threading模块"></a><code>Threading</code>模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"get detail html started"</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"get detail html end"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_detail_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"get detail url started"</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"get detail url end"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    thread1 = threading.Thread(target=get_detail_html, args=(<span class="string">""</span>,))</span><br><span class="line">    thread2 = threading.Thread(target=get_detail_url, args=(<span class="string">""</span>,))</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line">    print(<span class="string">"last time: &#123;&#125;"</span>.format(time.time() - start_time))</span><br></pre></td></tr></table></figure>
<h3 id="派生Thread的子类，并创建实例"><a href="#派生Thread的子类，并创建实例" class="headerlink" title="派生Thread的子类，并创建实例"></a>派生<code>Thread</code>的子类，并创建实例</h3><blockquote>
<p>需要重载<code>run</code>方法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetDetailHtml</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        super().__init__(name=name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"get detail html started"</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        print(<span class="string">"get detail html end"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetDetailUrl</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        super().__init__(name=name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"get detail url started"</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        print(<span class="string">"get detail url end"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    thread1 = GetDetailHtml(<span class="string">"get_detail_html"</span>)</span><br><span class="line">    thread2 = GetDetailUrl(<span class="string">"get_detail_url"</span>)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line">    print(<span class="string">"last time: &#123;&#125;"</span>.format(time.time() - start_time))</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a><code>Queue</code></h2><p>使用队列，可以进行阻塞操作。它是基于<code>deque</code>开发的，因而是线程安全的。<br>初始化：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line">msg_deque = Queue.Queue()</span><br></pre></td></tr></table></figure></p>
<p>放入队列：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg_deque.put(data)</span><br></pre></td></tr></table></figure></p>
<p>取出队列，没有时间默认阻塞等待：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg_deque.get(block=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p>
<p><code>msg_deque.task_done()</code>：每次从<code>queue</code>中<code>get</code>一个数据之后，当处理好相关问题，最后调用该方法，以提示<code>msg_deque.join()</code>是否停止阻塞。让线程向前执行或者退出：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q = queue.Queue(<span class="number">2</span>)</span><br><span class="line">q.put(<span class="number">15</span>)</span><br><span class="line">q.put(<span class="number">59</span>)</span><br><span class="line"></span><br><span class="line">q.get()</span><br><span class="line">q.task_done()  <span class="comment"># get取完队列中的一个值后，使用task_done方法告诉队列，我已经取出了一个值并处理完毕</span></span><br><span class="line">q.get()</span><br><span class="line">q.task_done()</span><br><span class="line"></span><br><span class="line">q.join()</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果没有<code>task_done</code>，那么会一直阻塞在<code>join</code>处</p>
</blockquote>
<p>队列类型：</p>
<ul>
<li>先进先出队列：<code>queue.Queue</code></li>
<li>后进先出队列：<code>queue.LifoQueue</code></li>
<li>优先级队列：<code>queue.PriorityQueue</code></li>
<li>双向队列：<code>queue.deque</code></li>
</ul>
<p>源码分析：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, item, block=True, timeout=None)</span>:</span></span><br><span class="line">   <span class="comment"># self.not_full是一个条件变量，如果size满足的话，直接进行put操作(append)，并且释放锁给get</span></span><br><span class="line">   <span class="comment"># 否则等待not_full(由get中的notify触发)</span></span><br><span class="line">    <span class="keyword">with</span> self.not_full:</span><br><span class="line">        <span class="keyword">if</span> self.maxsize &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> block:</span><br><span class="line">                <span class="keyword">if</span> self._qsize() &gt;= self.maxsize:</span><br><span class="line">                    <span class="keyword">raise</span> Full</span><br><span class="line">            <span class="keyword">elif</span> timeout <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">while</span> self._qsize() &gt;= self.maxsize:</span><br><span class="line">                    self.not_full.wait()</span><br><span class="line">            <span class="keyword">elif</span> timeout &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">"'timeout' must be a non-negative number"</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                endtime = time() + timeout</span><br><span class="line">                <span class="keyword">while</span> self._qsize() &gt;= self.maxsize:</span><br><span class="line">                    remaining = endtime - time()</span><br><span class="line">                    <span class="keyword">if</span> remaining &lt;= <span class="number">0.0</span>:</span><br><span class="line">                        <span class="keyword">raise</span> Full</span><br><span class="line">                    self.not_full.wait(remaining)</span><br><span class="line">        self._put(item)</span><br><span class="line">        self.unfinished_tasks += <span class="number">1</span></span><br><span class="line">        self.not_empty.notify()</span><br></pre></td></tr></table></figure></p>
<p><code>get</code>同理，如果<code>size</code>为空，则等待<code>not_empty</code>，否则通知<code>put</code>可进行操作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, block=True, timeout=None)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> self.not_empty:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> block:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self._qsize():</span><br><span class="line">                <span class="keyword">raise</span> Empty</span><br><span class="line">        <span class="keyword">elif</span> timeout <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> self._qsize():</span><br><span class="line">                self.not_empty.wait()</span><br><span class="line">        <span class="keyword">elif</span> timeout &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"'timeout' must be a non-negative number"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            endtime = time() + timeout</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> self._qsize():</span><br><span class="line">                remaining = endtime - time()</span><br><span class="line">                <span class="keyword">if</span> remaining &lt;= <span class="number">0.0</span>:</span><br><span class="line">                    <span class="keyword">raise</span> Empty</span><br><span class="line">                self.not_empty.wait(remaining)</span><br><span class="line">        item = self._get()</span><br><span class="line">        self.not_full.notify()</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure></p>
<h2 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h2><blockquote>
<p>除了<code>Lock</code>之外，还存在其他的锁</p>
</blockquote>
<p><strong><code>RLock</code></strong>：可重入锁，允许在<strong>同一线程</strong>中被调用多次，但是<code>acquire</code>与<code>release</code>的数量应当相等。<br><strong><code>Condition</code></strong>：条件同步机制，一个线程等待特定条件，另一个线程发出特定条件满足的信号。具有<code>wait</code>和<code>notify</code>两种方法。<code>Condition</code>实际上有两把锁，当使用<code>wait</code>方法时，会释放最外层的锁，并分配一把锁，加至<code>__waiters__</code>这个队列里，只有当调用<code>notify</code>方法时，才会从<code>__waiters</code>方法中释放锁。<br><strong><code>Semaphore</code></strong>：通过计数器限制可同时运行的线程数量。<code>acquire()</code>递减计数器，<code>release()</code>则是增加计数器。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, cond)</span>:</span></span><br><span class="line">        super().__init__(name=<span class="string">'client'</span>)</span><br><span class="line">        self.cond = cond</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self.cond:</span><br><span class="line">            self.cond.wait()</span><br><span class="line">            print(<span class="string">"client saying"</span>)</span><br><span class="line">            self.cond.notify()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, cond)</span>:</span></span><br><span class="line">        super().__init__(name=<span class="string">'server'</span>)</span><br><span class="line">        self.cond = cond</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self.cond:</span><br><span class="line">            print(<span class="string">"server saying"</span>)</span><br><span class="line">            self.cond.notify()</span><br><span class="line">            self.cond.wait()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    cond = threading.Condition()</span><br><span class="line">    server = Server(cond)</span><br><span class="line">    client = Client(cond)</span><br><span class="line">    client.start()</span><br><span class="line">    server.start()</span><br></pre></td></tr></table></figure></p>
<p><code>condition</code>源码分析：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">(self, timeout=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self._is_owned():</span><br><span class="line">       <span class="keyword">raise</span> RuntimeError(<span class="string">"cannot wait on un-acquired lock"</span>)</span><br><span class="line">   <span class="comment"># 获得一个内部锁</span></span><br><span class="line">   waiter = _allocate_lock()</span><br><span class="line">   waiter.acquire()</span><br><span class="line">   self._waiters.append(waiter)</span><br><span class="line">   <span class="comment"># 释放condition锁</span></span><br><span class="line">   saved_state = self._release_save()</span><br><span class="line">   gotit = <span class="literal">False</span></span><br><span class="line">   <span class="keyword">try</span>:    <span class="comment"># restore state no matter what (e.g., KeyboardInterrupt)</span></span><br><span class="line">       <span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">           <span class="comment"># 等待notify释放锁才能再次进入</span></span><br><span class="line">           waiter.acquire()</span><br><span class="line">           gotit = <span class="literal">True</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           <span class="keyword">if</span> timeout &gt; <span class="number">0</span>:</span><br><span class="line">               gotit = waiter.acquire(<span class="literal">True</span>, timeout)</span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               gotit = waiter.acquire(<span class="literal">False</span>)</span><br><span class="line">       <span class="keyword">return</span> gotit</span><br><span class="line">   <span class="keyword">finally</span>:</span><br><span class="line">      <span class="comment"># 恢复condition锁</span></span><br><span class="line">       self._acquire_restore(saved_state)</span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> gotit:</span><br><span class="line">           <span class="keyword">try</span>:</span><br><span class="line">               self._waiters.remove(waiter)</span><br><span class="line">           <span class="keyword">except</span> ValueError:</span><br><span class="line">               <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<p><strong><code>Semaphore</code></strong>：主要用于控制获取锁的数量<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlSpider</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url, sem)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.url = url</span><br><span class="line">        self.sem = sem</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">import</span> time</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        print(<span class="string">'success!'</span>)</span><br><span class="line">        self.sem.release()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UrlProducer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, sem)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.sem = sem</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">            self.sem.acquire()</span><br><span class="line">            html_thread = HtmlSpider(<span class="string">'http://www.baidu.com'</span>, self.sem)</span><br><span class="line">            html_thread.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sem = threading.Semaphore(<span class="number">3</span>)</span><br><span class="line">    url_procuder = UrlProducer(sem)</span><br><span class="line">    url_procuder.start()</span><br></pre></td></tr></table></figure></p>
<p><strong><code>Event</code></strong>：一个线程通知事件，其他线程等待事件。内置了一个初始为<code>False</code>的标志，当调用<code>set()</code>时为<code>True</code>，调用<code>clear()</code>时重置为<code>False</code>。包括一下方法：</p>
<ul>
<li><code>isSet()</code>：当内置标志为<code>True</code>时返回<code>True</code></li>
<li><code>set()</code>：将内置标志位置为<code>True</code></li>
<li><code>clear()</code>：将标志设为<code>False</code></li>
<li><code>wait[timeout]</code>：如果标志位为<code>True</code>将立即返回，否则阻塞线程至等待阻塞状态，等待其他线程调用<code>set()</code>。当<code>timeout</code>不为空时，如果发生了超时，则返回值为<code>False</code>，否则返回状态为<code>True</code>。</li>
</ul>
<p>举个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">event = threading.Event()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 等待事件，进入等待阻塞状态</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'%s wait for event...'</span> % threading.currentThread().getName()</span><br><span class="line">    event.wait()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 收到事件后进入运行状态</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'%s recv event.'</span> % threading.currentThread().getName()</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=func)</span><br><span class="line">t2 = threading.Thread(target=func)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送事件通知</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'MainThread set event.'</span></span><br><span class="line">event.set()</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在实际中，通常为每个线程准备一个独立的<code>Event</code>，而不是多个线程共享。应用场景，当用户成功上线了，才开启接收消息的线程。</p>
</blockquote>
<h2 id="concurrent-futures"><a href="#concurrent-futures" class="headerlink" title="concurrent.futures"></a><code>concurrent.futures</code></h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>使用标准库的<code>from concurrent.futures</code>下的<code>ThreadPoolExecutor</code>。<br>主线程可以获取某一个线程的状态或者某一个任务的状态(<code>done</code>)，以及返回值(<code>result</code>)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">return_future_result</span><span class="params">(message)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> message</span><br><span class="line">pool = ThreadPoolExecutor(max_workers=<span class="number">2</span>)  <span class="comment"># 创建一个最大可容纳2个task的线程池</span></span><br><span class="line">future1 = pool.submit(return_future_result, (<span class="string">"hello"</span>))  <span class="comment"># 往线程池里面加入一个task</span></span><br><span class="line">future2 = pool.submit(return_future_result, (<span class="string">"world"</span>))  <span class="comment"># 往线程池里面加入一个task</span></span><br><span class="line">print(future1.done())  <span class="comment"># 判断task1是否结束</span></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">print(future2.done())  <span class="comment"># 判断task2是否结束</span></span><br><span class="line">print(future1.result())  <span class="comment"># 查看task1返回的结果</span></span><br><span class="line">print(future2.result())  <span class="comment"># 查看task2返回的结果</span></span><br></pre></td></tr></table></figure></p>
<p><code>ThreadPoolExecutor(pool_count)</code>中<code>pool_count</code>代表创建线程的数量，会返回一个该线程池的执行者对象，这个对象的<code>submit()</code>方法和<code>map()</code>方法，能够使用线程池中的线程来执行我们指定的方法，并且返回一个<code>Future</code>对象。并且当线程结束之后会自动归还，如果线程全部被占用，则会阻塞。<br>如果需要添加参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">return_future_result</span><span class="params">(message, n)</span>:</span></span><br><span class="line">    time.sleep(n)</span><br><span class="line">    <span class="keyword">return</span> message</span><br><span class="line">pool = ThreadPoolExecutor(max_workers=<span class="number">2</span>)  <span class="comment"># 创建一个最大可容纳2个task的线程池</span></span><br><span class="line">future1 = pool.submit(return_future_result, <span class="string">"hello"</span>, <span class="number">2</span>)  <span class="comment"># 往线程池里面加入一个task</span></span><br><span class="line">future2 = pool.submit(return_future_result, <span class="string">"world"</span>, <span class="number">1</span>)  <span class="comment"># 往线程池里面加入一个task</span></span><br></pre></td></tr></table></figure></p>
<p>通过<code>as_completed()</code>方法获取已经完成的任务的结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> future <span class="keyword">in</span> as_completed(all_tasks):</span><br><span class="line">    print(future.result())</span><br></pre></td></tr></table></figure></p>
<p>或者使用<code>map</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> pool.map(get_url, urls):</span><br><span class="line">    print(data)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>与<code>as_completed</code>不同的是，<code>map</code>返回的不是<code>future</code>类型，同时输出顺序也与<code>urls</code>一致。</p>
</blockquote>
<p>主要有以下方法：</p>
<ul>
<li><code>submit</code>：立即返回</li>
<li><code>result</code>：获取执行结果</li>
<li><code>cancel</code>：取消<code>task</code>(未开始执行的)，成功返回<code>True</code>，失败返回<code>False</code></li>
<li><code>as_completed</code>：是一个生成器，先完成的<code>task</code>先返回，返回的是<code>future</code>类型</li>
<li><code>map</code>：根据传入的顺序进行返回，返回的直接是<code>future.result()</code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed, wait</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_url</span><span class="params">(times)</span>:</span></span><br><span class="line">    time.sleep(times)</span><br><span class="line">    print(<span class="string">"get page &#123;&#125; success"</span>.format(times))</span><br><span class="line">    <span class="keyword">return</span> times</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># task1 = executor.submit(get_url, (3))</span></span><br><span class="line"><span class="comment"># task2 = executor.submit(get_url, (2))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(task1.done())</span></span><br><span class="line"><span class="comment"># print(task2.cancel())</span></span><br><span class="line"></span><br><span class="line">urls = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">all_task = [executor.submit(get_url, (url)) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">wait(all_task)</span><br><span class="line">print(<span class="string">"all task done"</span>)</span><br><span class="line"><span class="comment"># for future in as_completed(all_task):</span></span><br><span class="line"><span class="comment">#     data = future.result()</span></span><br><span class="line"><span class="comment">#     print("get page &#123;&#125;".format(data))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for future in executor.map(get_url, urls):</span></span><br><span class="line"><span class="comment">#     print("get page &#123;&#125;".format(future))</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>上面演示了两种方法进行多线程下载的方式，一种是利用<code>as_completed()</code>，另一种是利用<code>ThreadPoolExecutor.map()</code>。<br>通过<code>ThreadPoolExecutor.submit()</code>方法返回的是<strong><code>futures</code>对象</strong>，作为<code>as_completed</code>的参数，因而可以调用其<code>result</code>方法，并且不会发生阻塞(因为<code>as_completed()</code>实际上是一个生成器)。<br>而针对后者，返回值是一个迭代器，通过其<code>__next__</code>方法调用各个<code>futures</code>的<code>result</code>方法，因此得到的是<strong><code>futures</code>的结果</strong>。<br>如果需要提交任务的函数是一样的，就可以简化成<code>map</code>。但是加入提交的任务函数不一样的，或者执行的过程之可能出现异常，就要用到<code>submit</code>。</p>
</blockquote>
<p>流程图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">|======================= In-process =====================|== Out-of-process ==|</span><br><span class="line"></span><br><span class="line">+----------+     +----------+       +--------+     +-----------+    +---------+</span><br><span class="line">|          |  =&gt; | Work Ids |    =&gt; |        |  =&gt; | Call Q    | =&gt; |         |</span><br><span class="line">|          |     +----------+       |        |     +-----------+    |         |</span><br><span class="line">|          |     | ...      |       |        |     | ...       |    |         |</span><br><span class="line">|          |     | 6        |       |        |     | 5, call() |    |         |</span><br><span class="line">|          |     | 7        |       |        |     | ...       |    |         |</span><br><span class="line">| Process  |     | ...      |       | Local  |     +-----------+    | Process |</span><br><span class="line">|  Pool    |     +----------+       | Worker |                      |  #1..n  |</span><br><span class="line">| Executor |                        | Thread |                      |         |</span><br><span class="line">|          |     +----------- +     |        |     +-----------+    |         |</span><br><span class="line">|          | &lt;=&gt; | Work Items | &lt;=&gt; |        | &lt;=  | Result Q  | &lt;= |         |</span><br><span class="line">|          |     +------------+     |        |     +-----------+    |         |</span><br><span class="line">|          |     | 6: call()  |     |        |     | ...       |    |         |</span><br><span class="line">|          |     |    future  |     |        |     | 4, result |    |         |</span><br><span class="line">|          |     | ...        |     |        |     | 3, except |    |         |</span><br><span class="line">+----------+     +------------+     +--------+     +-----------+    +---------+</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>executor.map</code>会创建多个<code>_WorkItem</code>对象，每个对象都传入了新创建的一个<code>Future</code>对象。</li>
<li>把每个<code>_WorkItem</code>对象然后放进一个叫做<code>「Work Items」</code>的<code>dict</code>中，键是不同的<code>「Work Ids」</code>。</li>
<li>创建一个管理<code>「Work Ids」</code>队列的线程<code>「Local worker thread」</code>，它能做2件事：<ul>
<li>从<code>「Work Ids」</code>队列中获取Work Id, 通过「Work Items」找到对应的<code>_WorkItem</code>。如果这个<code>Item</code>被取消了，就从<code>「Work Items」</code>里面把它删掉，否则重新打包成一个<code>_CallItem</code>放入<code>「Call Q」</code>这个队列。<code>executor</code>的那些进程会从队列中取<code>_CallItem</code>执行，并把结果封装成<code>_ResultItems</code>放入<code>「Result Q」</code>队列中。</li>
<li>从<code>「Result Q」</code>队列中获取<code>_ResultItems</code>，然后从<code>「Work Items」</code>更新对应的<code>Future</code>对象并删掉入口。</li>
</ul>
</li>
</ul>
<h2 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h2><p><code>multiprocess</code>中的方法与多线程的比较类似：</p>
<ul>
<li><code>apply_async</code>：非阻塞的，与之对应的是<code>apply</code>是阻塞的。所以需要使用<code>join</code>，否则在子进程还没开始运行之前主进程就已经完成退出了。</li>
<li><code>close</code>：关闭<code>pool</code>，使其不再接受新的任务</li>
<li><code>terminate</code>：结束工作进程，不再处理未完成的任务</li>
<li><code>join</code>：主进程阻塞，等待子进程的退出，<code>join</code>方法要在<code>close</code>或<code>terminate</code>之后使用。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(n)</span>:</span></span><br><span class="line">    time.sleep(n)</span><br><span class="line">    print(<span class="string">"sub_progress success"</span>)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pool  = multiprocessing.Pool(multiprocessing.cpu_count())</span><br><span class="line">    results = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        results.append(pool.apply_async(get_html, args=(i,)))</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">        print(result.get())</span><br></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sub_progress success</span><br><span class="line">sub_progress success</span><br><span class="line">sub_progress success</span><br><span class="line">sub_progress success</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p><code>Queue</code>：不能使用<code>from queue import Queue</code>，这种方式只适用于同一进程下不同线程之间的共享，在多进程编程中，每一个进程中都会产生一个相应的副本。应该使用<code>multiprocess.Queue</code>。但是，这个<code>Queue</code><strong>不能用于进程池</strong>。线程池中应该使用<code>Manager().Queue()</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="comment"># from queue import Queue</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(queue)</span>:</span></span><br><span class="line">    queue.put(<span class="string">"a"</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(queue)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    data = queue.get()</span><br><span class="line">    print(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    queue = Queue(<span class="number">10</span>)</span><br><span class="line">    my_producer = Process(target=producer, args=(queue,))</span><br><span class="line">    my_consumer = Process(target=consumer, args=(queue,))</span><br><span class="line">    my_consumer.start()</span><br><span class="line">    my_producer.start()</span><br><span class="line">    my_producer.join()</span><br><span class="line">    my_consumer.join()</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>Manager()</code>中定义了很多共享变量。</p>
</blockquote>
<p><code>Pipe</code>：只适用于两个进程之间的通信，但是复杂度没有<code>Queue</code>高。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue, Pool, Manager, Pipe</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    pipe.send(<span class="string">"a"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    print(pipe.recv())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    send_pipe, recv_pipe = Pipe()</span><br><span class="line">    my_producer = Process(target=producer, args=(send_pipe, ))</span><br><span class="line">    my_consumer = Process(target=consumer, args=(recv_pipe, ))</span><br><span class="line"></span><br><span class="line">    my_producer.start()</span><br><span class="line">    my_consumer.start()</span><br><span class="line">    my_producer.join()</span><br><span class="line">    my_consumer.join()</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuyinzi.github.io/2019/04/03/Python线程-进程/" data-id="cjuh8tofy0010gy8z7909slas" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>

    </footer>
  </div>
  
    
 <script src="/jquery/jquery.min.js"></script>
  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2019/04/10/《Redis设计与实现》读书笔记-第一部分/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          《Redis设计与实现》读书笔记 第一部分
        
      </div>
    </a>
  
  
    <a href="/2019/04/03/Test/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">Test</div>
    </a>
  
</nav>

  
</article>
 
   <!-- 
  <div class="comments" id="comments">
    
     
       
       
      
      
  </div>
  -->
  

</section>
           
    <aside id="sidebar">
  
    

  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#GIL"><span class="toc-number">1.</span> <span class="toc-text">GIL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#区别"><span class="toc-number">2.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">3.</span> <span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#join-和setDaemon"><span class="toc-number">4.</span> <span class="toc-text">join()和setDaemon()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建线程"><span class="toc-number">5.</span> <span class="toc-text">创建线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Threading模块"><span class="toc-number">5.1.</span> <span class="toc-text">Threading模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#派生Thread的子类，并创建实例"><span class="toc-number">5.2.</span> <span class="toc-text">派生Thread的子类，并创建实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Queue"><span class="toc-number">6.</span> <span class="toc-text">Queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#同步机制"><span class="toc-number">7.</span> <span class="toc-text">同步机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concurrent-futures"><span class="toc-number">8.</span> <span class="toc-text">concurrent.futures</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池"><span class="toc-number">8.1.</span> <span class="toc-text">线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程池"><span class="toc-number">9.</span> <span class="toc-text">进程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程间通信"><span class="toc-number">10.</span> <span class="toc-text">进程间通信</span></a></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2019 Littlemay&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;littlemay2015@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png">
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->



 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>