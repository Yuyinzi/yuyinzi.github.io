<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>面试知识点整理之网络篇 | Yuyinzi&#39;s note</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="面试时所必要，或者被问到的问题的记录，如果有理解错误或者疏漏，烦请指出，万分感谢：） TCP三次握手与四次挥手 为何需要四次挥手 出现大量TIME_WAIT应当如何处理 SYN FLOOD出现原因及原理">
<meta name="keywords" content="web">
<meta property="og:type" content="article">
<meta property="og:title" content="面试知识点整理之网络篇">
<meta property="og:url" content="http://yuyinzi.github.io/2019/05/11/面试知识点整理之网络篇/index.html">
<meta property="og:site_name" content="Yuyinzi&#39;s note">
<meta property="og:description" content="面试时所必要，或者被问到的问题的记录，如果有理解错误或者疏漏，烦请指出，万分感谢：） TCP三次握手与四次挥手 为何需要四次挥手 出现大量TIME_WAIT应当如何处理 SYN FLOOD出现原因及原理">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-06-17T07:02:10.524Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试知识点整理之网络篇">
<meta name="twitter:description" content="面试时所必要，或者被问到的问题的记录，如果有理解错误或者疏漏，烦请指出，万分感谢：） TCP三次握手与四次挥手 为何需要四次挥手 出现大量TIME_WAIT应当如何处理 SYN FLOOD出现原因及原理">
  
    <link rel="alternate" href="/atom.xml" title="Yuyinzi&#39;s note" type="application/atom+xml">
  
  
    <link rel="icon" href="/may.jpeg">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yuyinzi.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Yuyinzi&#39;s note</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-面试知识点整理之网络篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/11/面试知识点整理之网络篇/" class="article-date">
  <time datetime="2019-05-11T14:18:13.000Z" itemprop="datePublished">2019-05-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web/">Web</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      面试知识点整理之网络篇
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>面试时所必要，或者被问到的问题的记录，如果有理解错误或者疏漏，烦请指出，万分感谢：）</p>
<h2 id="TCP三次握手与四次挥手"><a href="#TCP三次握手与四次挥手" class="headerlink" title="TCP三次握手与四次挥手"></a><code>TCP</code>三次握手与四次挥手</h2><ol>
<li>为何需要四次挥手</li>
<li>出现大量<code>TIME_WAIT</code>应当如何处理</li>
<li><code>SYN FLOOD</code>出现原因及原理</li>
</ol>
<a id="more"></a>
<h2 id="浏览器中输入url到显示主页的过程"><a href="#浏览器中输入url到显示主页的过程" class="headerlink" title="浏览器中输入url到显示主页的过程"></a>浏览器中输入<code>url</code>到显示主页的过程</h2><ol>
<li>输入<code>url</code></li>
<li><code>DNS</code>解析：浏览器缓存-&gt;操作系统缓存-&gt;<code>hosts</code>文件-&gt;路由器缓存-&gt;<code>ISP DNS</code>缓存-&gt;顶级<code>DNS</code>-&gt;根<code>DNS</code>，向找到的域名服务器发起请求，将结果返回给用户，并且缓存下来</li>
<li>建立<code>TCP</code>连接</li>
<li>发送<code>HTTP</code>请求</li>
<li>服务器处理请求</li>
<li>服务器返回响应</li>
<li>浏览器渲染</li>
<li>连接结束</li>
<li>涉及到<code>HTTP</code>协议，<code>TCP</code>协议、<code>IP</code>协议和<code>DNS</code>协议等</li>
</ol>
<h2 id="TCP如何保证可靠传输"><a href="#TCP如何保证可靠传输" class="headerlink" title="TCP如何保证可靠传输"></a><code>TCP</code>如何保证可靠传输</h2><p>建立连接前，需要三次握手。数据传送时，有确认、重传、流量控制和拥塞控制机制。</p>
<h2 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a><code>HTTP</code>和<code>HTTPS</code>的区别</h2><p>所谓<code>HTTPS</code>, 其实就是身披<code>SSL</code>协议的这层外壳的<code>HTTP</code>。<code>HTTPS</code>采用混合加密机制，即交换密钥环节使用非对称加密方式，生成了会话密钥后，使用对称加密方式加密内容。</p>
<p><code>HTTPS</code>有如下特点：</p>
<ul>
<li>生成对话密钥总共需要三个随机数</li>
<li>握手之后的对话使用对话密钥(对称加密)，服务器的公钥和私钥只用于加密和解密对话密钥(非对称加密)，无其他作用</li>
<li>服务器公钥放在服务器的数字证书之中。只要证书是可信的，公钥就是可信的。</li>
<li>整个握手阶段都不加密，只取决于<code>premaster secret</code>(第三个随机数)是否能被破解</li>
</ul>
<p>所以两者区别主要有：</p>
<ol>
<li><code>HTTPS</code>协议需要到<code>ca</code>申请证书，一般免费证书较少，因而需要一定费用。</li>
<li><code>HTTP</code>是超文本传输协议，信息是明文传输，<code>HTTPS</code>则是具有安全性的<code>SSL</code>加密传输协议。</li>
<li><code>HTTP</code>和<code>HTTPS</code>使用的是完全不同的连接方式，用的端口也不一样，前者是<code>80</code>，后者是<code>443</code>。</li>
<li><code>HTTP</code>的连接很简单，是无状态的；<code>HTTPS</code>协议是由<code>SSL+HTTP</code>协议构建的可进行加密传输、身份认证的网络协议，比<code>HTTP</code>协议安全。</li>
</ol>
<h2 id="TCP和UDP协议的区别"><a href="#TCP和UDP协议的区别" class="headerlink" title="TCP和UDP协议的区别"></a><code>TCP</code>和<code>UDP</code>协议的区别</h2><p>主要分为是否面向连接，传输是否可靠，传输形式是报文还是字节流，以及传输效率，所需资源，应用场景和首部字节几个方面。</p>
<p>其中<code>HTTP</code>、<code>HTTPS</code>、<code>SMTP</code>、<code>POP3</code>、<code>FTP</code>、<code>TELNET</code>等是基于<code>TCP</code>的应用层协议。</p>
<p><code>DHCP</code>(动态获取<code>IP</code>地址，缺省网关等)、使用的是<code>UDP</code>的应用协议。</p>
<p><code>DNS</code>是基于<code>TCP/UDP</code>的应用层协议。</p>
<h2 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h2><ul>
<li><p>1xx，请求正在被处理</p>
</li>
<li><p>2xx，请求处理成功</p>
<ul>
<li><p>200，请求被成功处理</p>
</li>
<li><p>204，请求被成功处理，但响应的主体部分为空，适用于只需要客户端向服务端发送数据的情况(使用<code>DELETE</code>时返回204)</p>
</li>
<li>206，客户端进行了部分请求，服务端返回指定部分的内容</li>
</ul>
</li>
<li><p>3xx，需要重定向</p>
<ul>
<li><p>301，请求的资源被分配了新的URL，永久重定向</p>
</li>
<li><p>302，请求的资源被分配了新的URL，暂时重定向</p>
</li>
<li>303，同302，区别在于服务端要求客户端使用<code>GET</code>方法请求新的<code>URL</code></li>
<li>304，客户端进行附带条件的请求时，允许访问资源，但没满足条件，与重定向没有任何关系</li>
</ul>
</li>
<li><p>4xx，客户端错误或请求无法实现</p>
<ul>
<li><p>400，<code>Bad Request</code>，客户端请求有语法错误</p>
</li>
<li><p>401，<code>Unauthorized</code>，请求未经授权</p>
</li>
<li>403，<code>Forbidden</code>，请求的资源被服务器拒绝</li>
<li>404，<code>Not Found</code>，服务器上没有请求的资源</li>
</ul>
</li>
<li><p>5xx，服务器端错误，未能实现合法请求</p>
<ul>
<li><p>500，服务器在处理请求时出现了错误</p>
</li>
<li><p>503，服务器处于超负荷或维护状态，无法处理请求</p>
</li>
</ul>
</li>
</ul>
<p><code>301</code>和<code>302</code>的区别：</p>
<ul>
<li>302重定向是暂时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。 容易被网址劫持，导致网站降权。</li>
<li>301重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。</li>
</ul>
<h2 id="HTTP长连接和短连接"><a href="#HTTP长连接和短连接" class="headerlink" title="HTTP长连接和短连接"></a><code>HTTP</code>长连接和短连接</h2><p><code>HTTP/1.0</code>默认使用短连接，客户端和服务器每进行一次<code>HTTP</code>操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个<code>HTML</code>或其他类型的<code>Web</code>页中包含有其他的<code>Web</code>资源（如<code>JavaScript</code>文件、图像文件、<code>CSS</code>文件等），每遇到这样一个<code>Web</code>资源，浏览器就会重新建立一个<code>HTTP</code>会话。</p>
<p>从<code>HTTP/1.1</code>起，默认使用长连接。响应头会加入：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure>
<p>一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。长连接情况下，客户端和服务器之间用于传输<code>HTTP</code>的<code>TCP</code>连接不会关闭，再次访问服务器时会复用该连接。它并不是永久保持连接，具有一个保持时间，并且需要客户端和服务器都支持长连接。</p>
<h2 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a><code>cookie</code>和<code>session</code>的区别</h2><ul>
<li><code>cookie</code>中只能保存<code>ascii</code>字符串，但是<code>session</code>可以存取任何类型的数据</li>
<li><code>cookie</code>存储在客户端本地中，对客户端是可见的，其他程序可能会窥探、复制甚至修改；而<code>session</code>存储在服务器中，不存在敏感信息泄露的风险</li>
<li><code>cookie</code>可以带来更长有效期的登录状态的保持，而<code>session</code>只要关闭了浏览器则会失效(随着存储在浏览器进程中的会话<code>cookie</code>的消失而消失，并不是服务器端主动删除)，如果超时时间过长，会导致服务器内存溢出</li>
<li><code>cookie</code>保管在客户端，不占用服务器资源；<code>session</code>存储在服务器端，并发量高的时候容易耗费大量的内存，给服务器带来巨大的压力</li>
<li><code>cookie</code>需要浏览器的支持，如果浏览器不支持<code>cookie</code>，需要运用<code>session</code>以及<code>URL</code>地址重写。<code>cookie</code>既支持本浏览器窗口以及子窗口内有效，也能够设为一些浏览器窗口有效。但是<code>session</code>只能在此次浏览器或者其子窗口有效。</li>
<li><code>cookie</code>支持跨域访问；<code>session</code>仅在所在域名有效。</li>
</ul>
<h2 id="HTTP的报文格式"><a href="#HTTP的报文格式" class="headerlink" title="HTTP的报文格式"></a><code>HTTP</code>的报文格式</h2><p><code>HTTP</code>请求报文由请求行、请求头部、空行(回车+换行)和请求正文组成。</p>
<p><code>HTTP</code>响应报文由状态航、消息报头、空行和响应正文组成。</p>
<h2 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a><code>HTTP</code>请求方法</h2><ul>
<li><code>GET</code>： 获取资源</li>
<li><code>POST</code>：传输实体主体，并返回处理数据后的结果</li>
<li><code>PUT</code>：传输文件</li>
<li><code>HEAD</code>：获得报文首部，只是获取的是报文首部，用来确定客户端输入的<code>URI</code>的有效性和资源更新的日期时间</li>
<li><code>DELETE</code>：删除文件</li>
<li><code>OPTIONS</code>：询问服务器支持哪种方法</li>
<li><code>TRACE</code>：回显服务器收到的请求，主要用于测试和诊断</li>
<li><code>CONNECT</code>：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</li>
<li><code>PATCH</code>: 一般用于资源的部分更新，而<code>PUT</code>一般用于资源的整体更新。 当资源不存在时，<code>PATCH</code>会创建一个新的资源，而<code>PUT</code>只会对已存在资源进行更新。</li>
</ul>
<h2 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a><code>GET</code>和<code>POST</code>的区别</h2><ul>
<li><p><code>GET</code>语义上是幂等的，<code>POST</code>不是</p>
</li>
<li><p><code>GET</code>提交，请求的数据会附在<code>URL</code>之后，<code>POST</code>提交是将提交的数据放置在<code>HTTP</code>包的包体中。因此，<code>GET</code>提交的数据会在地址栏中显示出来，而<code>POST</code>提交，地址栏不会改变。</p>
</li>
<li>虽然<code>HTTP</code>协议没有对传输的数据大小进行限制，<code>HTTP</code>协议规范也没有对<code>URL</code>长度进行限制，但是由于特定浏览器和服务器对<code>URL</code>长度有限制，因此<code>GET</code>提交时，传输数据就会受到<code>URL</code>长度的限制。而<code>POST</code>提交不是通过<code>URL</code>传值，理论上数据不受限，但实际各个<code>WEB</code>服务器会规定对<code>POST</code>提交数据大小进行限制。</li>
<li>通过<code>GET</code>提交数据，用户名和密码将出现在<code>URL</code>中，带来很大的安全隐患，除此之外，还可能会造成<code>CSRF</code>攻击。</li>
</ul>
<h2 id="XSS和CSRF的区别"><a href="#XSS和CSRF的区别" class="headerlink" title="XSS和CSRF的区别"></a><code>XSS</code>和<code>CSRF</code>的区别</h2><p><code>xss</code>原理上市利用<code>js</code>脚本注入，从而达到盗取用户<code>Cookie</code>、破坏页面结构、重定向到其它网站等攻击手段。</p>
<p>而<code>csrf</code>原理上利用的是网站服务器端参数可预先构造的原理，拼接构造好<code>url</code>，引用用户提交请求。</p>
<p><code>xss</code>防范方法：</p>
<ul>
<li>使用<code>HttpOnly</code>防止<code>js</code>获取<code>cookie</code>，这个标记是在服务器端向客户端发送<code>set-cookie</code>时标记的</li>
<li>需要对用户的输入进行处理，只允许输入合法的值，其它值一概过滤掉。</li>
</ul>
<p><code>csrf</code>防范方法：</p>
<p>本质是要求网站能够识别出哪些请求是非正常用户主动发起的。因此需要在请求中嵌入一些额外的授权数据，让网站服务器能够区分出这些未授权的请求。可以利用：</p>
<ol>
<li><code>GET</code> 请求不对数据进行修改</li>
<li>不让第三方网站访问到用户<code>Cookie</code></li>
<li>阻止第三方网站请求接口</li>
<li>请求时附带验证信息，比如验证码或者<code>token</code></li>
</ol>
<h2 id="为什么会有OPTIONS请求"><a href="#为什么会有OPTIONS请求" class="headerlink" title="为什么会有OPTIONS请求"></a>为什么会有<code>OPTIONS</code>请求</h2><p><code>OPTIONS</code>的用途主要有：</p>
<ul>
<li>获取服务器支持的<code>HTTP</code>请求</li>
<li>用来检查服务器的性能，例如<code>AJAX</code>进行跨域请求时的预检，需要向另外一个域名的资源发送一个<code>HTTP OPTIONS</code>请求头，用以判断实际发送的请求是否安全。</li>
</ul>
<p>一般都是浏览检测到请求跨域时，会自动发起预检请求，以检测实际请求是否可以被服务器所接受。预检请求报文中的<code>Access-Control-Request-Method</code>首部字段告知服务器实际请求所使用的<code>HTTP</code>方法；<code>Access-Control-Request-Headers</code>首部字段告知服务器实际请求所携带的自定义首部字段。服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求。</p>
<p>当满足下面任意一个条件(即非简单请求)时，浏览器会发送<code>OPTIONS</code>请求：</p>
<ul>
<li>请求方法不是<code>GET/HEAD/POST</code>之一</li>
<li>请求头的<code>Content-Type</code>不是下列之一：<ul>
<li><code>application/x-www-form-urlencoded</code></li>
<li><code>multipart/form-data</code></li>
<li><code>text/plain</code></li>
</ul>
</li>
<li>人为设置了<a href="https://fetch.spec.whatwg.org/#cors-safelisted-request-header" target="_blank" rel="noopener">对 CORS 安全的首部字段集合</a>之外的其他首部字段</li>
</ul>
<h2 id="同源和跨域"><a href="#同源和跨域" class="headerlink" title="同源和跨域"></a>同源和跨域</h2><p>所谓同源是指：</p>
<ul>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同</li>
</ul>
<p><code>CORS</code>可以允许浏览器向跨源服务器发出请求，从而克服了<code>AJAX</code>只能<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">同源</a>使用的限制。需要服务器和浏览器同时支持，不需要用户参与，所有浏览器都支持，因此只要服务器实现了<code>CORS</code>，就可以跨源通信。</p>
<h2 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h2><h3 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h3><p>根据密钥类型不同将现代密码技术分为两类：对称加密算法和非对称加密算法。</p>
<p>对称加密，常用的有<code>DES</code>、<code>3DES</code>、<code>AES</code>，特点有：</p>
<ol>
<li>加密方和解密方使用同一个密钥。</li>
<li>加密解密的速度比较快，适合数据比较长时的使用。</li>
<li>密钥传输的过程不安全，且容易被破解，密钥管理也比较麻烦。</li>
</ol>
<p>非对称加密，加密密钥(公钥)和解密密钥(私钥)是不同的。常见的有<code>RSA</code>、<code>DSA</code>。</p>
<p>总结：</p>
<ul>
<li>由于非对称加密算法的运行速度比对称加密算法的速度慢很多，当我们需要加密大量的数据时，建议采用对称加密算法，提高加解密速度。</li>
<li>对称加密算法不能实现签名，因此签名只能非对称算法。</li>
<li>由于对称加密算法的密钥管理是一个复杂的过程，密钥的管理直接决定着他的安全性，因此当数据量很小时，我们可以考虑采用非对称加密算法。</li>
</ul>
<p>在实际的操作过程中，我们通常采用的方式是：<strong>采用非对称加密算法管理对称算法的密钥，然后用对称加密算法加密数据</strong>。这样我们就集成了两类加密算法的优点，既实现了加密速度快的优点，又实现了安全方便管理密钥的优点。</p>
<h3 id="单向加密"><a href="#单向加密" class="headerlink" title="单向加密"></a>单向加密</h3><p>另外还存在单向加密算法，散列算法，主要有：</p>
<ul>
<li><code>MD5</code>：实际上是摘要算法，无论多长都会输出<code>128bits</code>的摘要</li>
<li><code>SHA1</code>：安全性更强，会产生一个<code>160bits</code>的摘要</li>
</ul>
<p>单向加密算法不可逆，用在检查数据完整性以及数字签名场景中。</p>
<p>比方说，服务器方将内容使用散列算法，生成摘要。然后再使用服务器端的私钥对摘要进行加密，生成数字签名。客户端接收到内容后，使用服务证书中的公钥对数字签名进行解密，获得摘要，再将内容通过散列算法生成的摘要进行比对，从而证明内容来自于服务器并且并未被修改过。</p>
<p>===========2019年05月17日11:18:09更新分割==============</p>
<h2 id="HTTP1-0-HTTP1-1-HTTP2-0的区别"><a href="#HTTP1-0-HTTP1-1-HTTP2-0的区别" class="headerlink" title="HTTP1.0/HTTP1.1/HTTP2.0的区别"></a><code>HTTP1.0</code>/<code>HTTP1.1</code>/<code>HTTP2.0</code>的区别</h2><p><a href="https://juejin.im/entry/5981c5df518825359a2b9476" target="_blank" rel="noopener">HTTP1.0、HTTP1.1 和 HTTP2.0 的区别</a></p>
<p>首先是<code>HTTP1.0</code>和<code>HTTP1.1</code>的区别：</p>
<ul>
<li>缓存处理，<code>HTTP1.1</code>引入了更多的缓存控制策略，例如<code>Entity tag</code>、<code>If-Unmodified-Since</code>、 <code>If-Match</code>、<code>If-None-Match</code>等。</li>
<li>带宽优化及网络连接的使用：<code>HTTP1.1</code>在请求头引入了<code>range</code>域，支持断点续传</li>
<li>错误通知的管理：新增了24个错误状态响应码</li>
<li><code>Host</code>头处理：<code>HTTP1.1</code>支持<code>Host</code>头域，使得浏览器可以向一台物理服务器上的多个虚拟主机发起请求</li>
<li>长连接</li>
</ul>
<p><code>HTTP2.0</code>相比<code>HTTP1.X</code>的新特性：</p>
<ul>
<li>新的二进制格式：<code>HTTP1.X</code>的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制格式，实现方便且健壮。</li>
<li>多路复用：连接共享，一个<code>request</code>对应一个<code>id</code>，这样一个连接上可以有多个<code>request</code>，每个连接的<code>request</code>可以随机的混杂在一起，接收方可以根据<code>request</code>的 <code>id</code>将<code>request</code>再归属到各自不同的服务端请求里面。</li>
<li><code>header</code>压缩：<code>HTTP1.X</code>的<code>header</code>带有大量信息，而且每次都要重复发送，<code>HTTP2.0</code>使用encoder来减少需要传输的<code>header</code>大小，通讯双方各自<code>cache</code>一份<code>header fields</code>表，既避免了重复<code>header</code>的传输，又减小了需要传输的大小。</li>
<li>服务端推送：例如网页有一个<code>sytle.css</code>的请求，在客户端收到<code>sytle.css</code>数据的同时，服务端会将<code>sytle.js</code>的文件推送给客户端，省去了客户端重复请求的步骤。</li>
</ul>
<blockquote>
<p>多路复用和长连接复用的区别在于：长连接复用是若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会；而多路复用可以使得多个请求在同一个连接上并行执行，某个请求耗时严重并不会影响其他请求。</p>
</blockquote>
<h2 id="如何验证HTTPS证书的合法性"><a href="#如何验证HTTPS证书的合法性" class="headerlink" title="如何验证HTTPS证书的合法性"></a>如何验证<code>HTTPS</code>证书的合法性</h2><p><a href="https://www.zhihu.com/question/37370216" target="_blank" rel="noopener">浏览器如何验证HTTPS证书的合法性？</a></p>
<ol>
<li>浏览器内置了信任的根证书，进行<code>SSL</code>握手时，服务器端会返回自己的证书</li>
<li>拿到证书后验证其数字签名。具体就是，根据证书上写的<code>CA</code>签发机构，在浏览器内置的根证书里找到对应的公钥，用此公钥解开数字签名，得到摘要（<code>digest</code>,证书内容的<code>hash</code>值），据此验证证书的合法性。</li>
<li>如果验证失败，会尝试查询证书吊销列表(<code>CRL</code>)和在线证书检查(<code>OCSP</code>)</li>
</ol>
<p>====================2019年05月22日17:19:49更新=============</p>
<h2 id="如何设计可靠的udp协议"><a href="#如何设计可靠的udp协议" class="headerlink" title="如何设计可靠的udp协议"></a>如何设计可靠的<code>udp</code>协议</h2><p><a href="https://www.infoq.cn/article/how-to-make-udp-reliable" target="_blank" rel="noopener">怎么让不可靠的 UDP 可靠？</a></p>
<ol>
<li><p>如果要可靠的话，需要增加<code>seq/ack</code>机制(业务层），确保数据发送到对端。</p>
</li>
<li><p>增加发送和接收缓冲区，实现重传。重传方案有：</p>
</li>
</ol>
<ul>
<li>定时重传：超过<code>RTO</code>时间，则进行重传，适用于小带宽低延迟(将<code>RTO</code>设计的很小)</li>
<li>请求重传：后续<code>ACK</code>携带丢失包信息，适用于带宽较大的传输场景</li>
<li><code>FEC</code>选择重传：会发送一些冗余包，可以通过<code>FEC</code>进行恢复，适合演示敏感且随机丢包的传输场景</li>
</ul>
<p>增加了重传可能会带来网络风暴，所以必要的时候可以设计窗口进行拥塞处理。如果需要数据严格有序，接收端还应该做好窗口排序和缓冲。</p>
<h2 id="OSI模型与TCP-IP协议"><a href="#OSI模型与TCP-IP协议" class="headerlink" title="OSI模型与TCP/IP协议"></a><code>OSI</code>模型与<code>TCP/IP</code>协议</h2><p><code>OSI</code>总共有七层，分别是物理层，数据链路层，网络层，传输层，会话层，表示层和应用层。</p>
<p><code>TCP/IP</code>模型分为了四层，分别是链路层，网络层，传输层和应用层。</p>
<h2 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a><code>IP</code>地址分类</h2><p>32位<code>IP</code>地址分为网络位和地址位，分为<code>A</code>、<code>B</code>、<code>C</code>三类以及特殊地址<code>D</code>和<code>E</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">A类地址</span><br><span class="line">  0.  0.  0.  0 = 00000000.00000000.00000000.00000000</span><br><span class="line">127.255.255.255 = 01111111.11111111.11111111.11111111</span><br><span class="line">    		子网掩码 = 255.0.0.0       </span><br><span class="line">B类地址</span><br><span class="line">128.  0.  0.  0 = 10000000.00000000.00000000.00000000</span><br><span class="line">191.255.255.255 = 10111111.11111111.11111111.11111111</span><br><span class="line">        子网掩码 = 255.255.0.0</span><br><span class="line">C类地址</span><br><span class="line">192.  0.  0.  0 = 11000000.00000000.00000000.00000000</span><br><span class="line">223.255.255.255 = 11011111.11111111.11111111.11111111</span><br><span class="line">				子网掩码 = 255.255.255.0</span><br><span class="line">D类地址</span><br><span class="line">224.  0.  0.  0 = 11100000.00000000.00000000.00000000</span><br><span class="line">239.255.255.255 = 11101111.11111111.11111111.11111111</span><br><span class="line"></span><br><span class="line">E类地址</span><br><span class="line">240.  0.  0.  0 = 11110000.00000000.00000000.00000000</span><br><span class="line">255.255.255.255 = 11111111.11111111.11111111.11111111</span><br></pre></td></tr></table></figure>
<h2 id="各层的协议"><a href="#各层的协议" class="headerlink" title="各层的协议"></a>各层的协议</h2><p>网络层：</p>
<ul>
<li><code>ARP</code>/<code>RARP</code></li>
<li><code>ICMP</code>：<code>ping</code>和<code>traceroute</code>都是基于此的工具</li>
</ul>
<p>传输层：</p>
<ul>
<li><code>TCP</code>：<code>SMTP</code>/<code>TELNET</code>/<code>HTTP</code>/<code></code>FTP</li>
<li><code>UDP</code>：<code>TFTP</code>/<code>SNMP</code>/<code>NFS</code></li>
</ul>
<h2 id="有了IP地址，为什么还需要MAC地址"><a href="#有了IP地址，为什么还需要MAC地址" class="headerlink" title="有了IP地址，为什么还需要MAC地址"></a>有了<code>IP</code>地址，为什么还需要<code>MAC</code>地址</h2><ol>
<li>优点：可以根据<code>IP</code>划分子网，方便路由</li>
<li>必要性：<code>IP</code>层也需要物理根基，因特网离不开以太网</li>
</ol>
<h2 id="集线器、交换机和路由器，网卡"><a href="#集线器、交换机和路由器，网卡" class="headerlink" title="集线器、交换机和路由器，网卡"></a>集线器、交换机和路由器，网卡</h2><p>集线器工作在物理层</p>
<p>交换机工作在链路层，通过<code>MAC</code>地址传送信息</p>
<p>路由器工作在网络层，存在路由表进行<code>IP</code>寻址</p>
<p>网卡的作用将数据封装成帧，通过网线发送出去；将帧组合成数据，发送给计算机，工作在数据链路层。</p>
<h2 id="同步异步，阻塞与非阻塞"><a href="#同步异步，阻塞与非阻塞" class="headerlink" title="同步异步，阻塞与非阻塞"></a>同步异步，阻塞与非阻塞</h2><p>[<a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a>]</p>
<ul>
<li>同步在进行数据拷贝时会将进程阻塞</li>
<li><p>异步是将数据拷贝完之后才通知进程，进程不会被阻塞。</p>
</li>
<li><p>阻塞会一直阻塞住对应的进程，直到操作完成(包括数据从内核空间拷贝至用户空间)；</p>
</li>
<li>非阻塞会在内核还准备数据的情况下返回，当数据准备好后，需要进程<strong>主动</strong>调用<code>recvfrom</code>将数据拷贝至用户空间，在数据从内核空间拷贝至用户空间时，仍然会阻塞进程</li>
</ul>
<p>因此阻塞与非阻塞<code>IO</code>都是同步<code>IO</code>。</p>
<h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a><code>I/O</code>多路复用</h2><p><code>IO multiplexing</code>就是我们说的<code>select</code>，<code>poll</code>，<code>epoll</code>，有些地方也称这种<code>IO</code>方式为<code>event driven IO</code>。<code>select/epoll</code>的好处就在于单个<code>process</code>就可以同时处理多个网络连接的<code>IO</code>。它的基本原理就是<code>select</code>，<code>poll</code>，<code>epoll</code>监听所负责的所有<code>socket</code>，当某个<code>socket</code>有数据到达了，就通知用户进程进行拷贝。因此这种方式仍然是同步<code>IO</code>。</p>
<h2 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select/poll/epoll"></a><code>select</code>/<code>poll</code>/<code>epoll</code></h2><p><code>select</code>将监听描述符分为3类，直到有监听的事件发生时返回，通过遍历描述符集合，来找到就绪的描述符。</p>
<p>缺点：</p>
<ul>
<li>监听描述符有限制，为1024</li>
<li>每次调用时需要将文件描述符从用户空间拷贝到内核空间，当有事件发生时，需要再将描述符从内和线性拷贝到用户空间</li>
<li>每次调用都会线性扫描整个<code>fd_set</code></li>
<li>再次调用时需要初始化所有描述符(<code>select</code>返回后会把以前加入的但并无事件发生的<code>fd</code>清空)</li>
</ul>
<p>因此<code>poll</code>进行了改进，使用一个指针代替描述符，解决了描述符数量限制与重新初始化的问题。</p>
<p><code>epoll</code>使用了一棵红黑树以及就绪队列，每当添加事件时，会往红黑树添加，并且向内核注册回调，当有事件发生时，回调函数会将就绪的<code>socket</code>放置就绪队列，因此，解决了遍历的问题。它支持<code>LT</code>和<code>ET</code>：</p>
<ul>
<li><strong>LT模式</strong>：当<code>epoll_wait</code>检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用<code>epoll_wait</code>时，会再次响应应用程序并通知此事件。</li>
<li><strong>ET模式</strong>：当<code>epoll_wait</code>检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用<code>epoll_wait</code>时，不会再次响应应用程序并通知此事件。</li>
</ul>
<h2 id="SQL注入和DDos"><a href="#SQL注入和DDos" class="headerlink" title="SQL注入和DDos"></a><code>SQL</code>注入和<code>DDos</code></h2><p><code>SQL</code>注入是指在填写某些字段的时候，字段中带有某些特殊字符(<code>sql</code>语法)，并未对字段中的数据进行验证。由于缺乏<code>sql</code>的转义，从而使得原本<code>sql</code>语句失效。通过修改数据库来修改网页上的内容。</p>
<p>从层次上<code>DDoS</code>可以分为：</p>
<ul>
<li><p>网络层<code>DDoS</code>:</p>
<ul>
<li><p><code>SYN Flood</code>: 三次握手时，当攻击方随意构造源IP去发送<code>SYN</code>包，服务器返回的<code>SYN+ACK</code>并不能得到正确应答，这时服务器会尝试重新发送并且等待，导致资源饱和和服务不可用</p>
</li>
<li><p><code>ACK Flood</code>：<code>TCP</code>建立之后，大量发送<code>ACK</code>，会导致服务器端花费大量的精力接收报文，并且判断数据包是否合法，同时要主动回应<code>RST</code>报文，正常的数据包可能就无法得到及时的处理</p>
</li>
<li><code>UDP Flood</code>：由于<code>UDP</code>协议是一种无连接的服务，在<code>UDP Flood</code>攻击中，攻击者可发送大量伪造源IP地址的小<code>UDP</code>包。</li>
<li><code>ICMP Flood</code>：在短时间内向目的主机发送大量<code>ping</code>包，消耗主机资源，主机资源耗尽后就会瘫痪或者无法提供其他服务。</li>
</ul>
</li>
<li><p>应用层<code>DDos</code>：</p>
<ul>
<li><p><code>CC</code>攻击： 针对消耗资源比较大的页面不断发起不正常的请求，导致资源耗尽。比如需要查询数据库的页面，读写硬盘文件。使用爬虫对这些网页发起<code>HTTP</code>请求。</p>
</li>
<li><p><code>DNS Flood</code>：向被攻击的服务器发送大量的域名解析请求(通常是随机生成或者是根本不存在的域名)，被攻击的<code>DNS</code>服务器在解析域名的过程会带来很大的负载。</p>
</li>
<li><code>HTTP</code>慢速连接攻击：针对<code>HTTP</code>协议，建立其连接之后，设置一个较大的<code>Content-Length</code>，每次只发送很少的字节，让服务器一直以为<code>HTTP</code>头部没有传输完成，连接一多就很快会出现连接耗尽。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuyinzi.github.io/2019/05/11/面试知识点整理之网络篇/" data-id="cjx6510p9006urt8zw482ot9t" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web/">web</a></li></ul>

    </footer>
  </div>
  
    
 <script src="/jquery/jquery.min.js"></script>
  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2019/05/13/面试知识点整理之存储篇/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          面试知识点整理之存储篇
        
      </div>
    </a>
  
  
    <a href="/2019/05/10/Leetcode-5-求最长回文子序列/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">Leetcode 5 求最长回文子序列</div>
    </a>
  
</nav>

  
</article>
 
   <!-- 
  <div class="comments" id="comments">
    
     
       
       
      
      
  </div>
  -->
  

</section>
           
    <aside id="sidebar">
  
    

  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP三次握手与四次挥手"><span class="toc-number">1.</span> <span class="toc-text">TCP三次握手与四次挥手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器中输入url到显示主页的过程"><span class="toc-number">2.</span> <span class="toc-text">浏览器中输入url到显示主页的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP如何保证可靠传输"><span class="toc-number">3.</span> <span class="toc-text">TCP如何保证可靠传输</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP和HTTPS的区别"><span class="toc-number">4.</span> <span class="toc-text">HTTP和HTTPS的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP和UDP协议的区别"><span class="toc-number">5.</span> <span class="toc-text">TCP和UDP协议的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见的状态码"><span class="toc-number">6.</span> <span class="toc-text">常见的状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP长连接和短连接"><span class="toc-number">7.</span> <span class="toc-text">HTTP长连接和短连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie和session的区别"><span class="toc-number">8.</span> <span class="toc-text">cookie和session的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP的报文格式"><span class="toc-number">9.</span> <span class="toc-text">HTTP的报文格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP请求方法"><span class="toc-number">10.</span> <span class="toc-text">HTTP请求方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GET和POST的区别"><span class="toc-number">11.</span> <span class="toc-text">GET和POST的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XSS和CSRF的区别"><span class="toc-number">12.</span> <span class="toc-text">XSS和CSRF的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么会有OPTIONS请求"><span class="toc-number">13.</span> <span class="toc-text">为什么会有OPTIONS请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#同源和跨域"><span class="toc-number">14.</span> <span class="toc-text">同源和跨域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#加密方式"><span class="toc-number">15.</span> <span class="toc-text">加密方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#对称加密和非对称加密"><span class="toc-number">15.1.</span> <span class="toc-text">对称加密和非对称加密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单向加密"><span class="toc-number">15.2.</span> <span class="toc-text">单向加密</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP1-0-HTTP1-1-HTTP2-0的区别"><span class="toc-number">16.</span> <span class="toc-text">HTTP1.0/HTTP1.1/HTTP2.0的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何验证HTTPS证书的合法性"><span class="toc-number">17.</span> <span class="toc-text">如何验证HTTPS证书的合法性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何设计可靠的udp协议"><span class="toc-number">18.</span> <span class="toc-text">如何设计可靠的udp协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OSI模型与TCP-IP协议"><span class="toc-number">19.</span> <span class="toc-text">OSI模型与TCP/IP协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP地址分类"><span class="toc-number">20.</span> <span class="toc-text">IP地址分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#各层的协议"><span class="toc-number">21.</span> <span class="toc-text">各层的协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#有了IP地址，为什么还需要MAC地址"><span class="toc-number">22.</span> <span class="toc-text">有了IP地址，为什么还需要MAC地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集线器、交换机和路由器，网卡"><span class="toc-number">23.</span> <span class="toc-text">集线器、交换机和路由器，网卡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#同步异步，阻塞与非阻塞"><span class="toc-number">24.</span> <span class="toc-text">同步异步，阻塞与非阻塞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O多路复用"><span class="toc-number">25.</span> <span class="toc-text">I/O多路复用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#select-poll-epoll"><span class="toc-number">26.</span> <span class="toc-text">select/poll/epoll</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL注入和DDos"><span class="toc-number">27.</span> <span class="toc-text">SQL注入和DDos</span></a></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2019 Littlemay&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;littlemay2015@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png">
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->



 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>