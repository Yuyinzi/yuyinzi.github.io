---
title: TCP学习记录
date: 2019-04-14 16:25:53
tags:
- web
categories:
- Web
---

网络模型可以概括为五层结构：

- 应用层
- 传输层
- 网络层
- 链路层
- 物理层

其中`TCP`位于传输层，主要用于保证通信的完整性及可靠性。

<!-- more -->

## 包的组成

![TCP-header.jpg](/assets/TCP-Header-01.jpg)

- 源端口与目的端口分别占`2`个字节
- 数据序号与确认序号分别占`4`个字节
- 数据偏移(数据距离包头有多少个`32`位)占`4`位，保留位(未使用，应清零)占`6`位，控制位占`6`位，窗口大小(控制对方发送数据大小)占`2`个字节。其中控制位包括：
  - 紧急位(`URG`)：与紧急指针配合使用，表明有紧急数据进行传送
  - 确认位(`ACK`)：仅当该位为`1`确认序号有效，`TCP`连接建立后，都会置为`1`
  - 推送位(`PSH`)：当接收方收到带有该字段的报文时，应当尽快交付数据，而不再等到整个缓存都填满了之后才进行交付
  - 复位位(`RST`)：`TCP`出现严重差错，释放连接
  - 同步位(`SYN`)：在连接建立时用来同步序号，当`SYN=1`而`ACK=0`时，表明是连接请求报文段，当握手完成后置为`0`
  - 终止位(`FIN`)：表明此报文的发送方的数据已发送完毕，并要求释放连接
- 包校验和：占`2`个字节
- 紧急指针：占`2`个字节，当且仅当`URG=1`时才有意义，指出在本报文段中的紧急数据的字节数(紧急数据结束后就是普通数据)，即使窗口为`0`也可以发送紧急数据
- 可选选项：长度可变，最长可以到达`40`字节

> `TCP`数据包在`IP`数据包的负载里头，头信息最少需要`20`字节，因此`TCP`数据包最大负载是`1460`字节(`IP`数据包的负载最多为`1480`)。

## 三次握手与四次挥手

对于`TCP`，最经典的莫过于三次握手和四次挥手：

![tcp_connect_close.jpg](/assets/tcp_open_close.jpg)

三次握手主要用于初始化序列号的初始值，相互通知对方自己的初始化序列号(`ISN`)，作为以后数据通信的序号。

四次挥手是由于`TCP`是全双工的，发送端和接收端都需要`FIN`和`ACK`。

### 三次握手

#### 序号

`ISN`是不可以固定的。否则可能在连接中断之后的网络重连，导致数据混乱。

在后续传输中，数据传输中的序列号是逐渐增加且与字节数相关的。例如：

![tcp_seq.jpg](/assets/tcp_seq.jpg)

每一次发送的`Seq`是对方`ACK`所期待的序号，如果此次发送携带了长度，则对方的`ACK`会加上此次发送的数据长度。

#### 初始化连接时`SYN`超时

当`client`发送`SYN`给`server`后，如果`client`发生故障，导致`server`回发的`SYN-ACK`没有收到`client`的确认，这时需要超时时间让`server`将这个连接断开，否则会一直占用`server`的`SYN`连接队列的位置，直至将其耗尽。

默认情况下，`Linux`会进行`5`次重发`SYN-ACK`，重试的间隔时间从`1s`开始每次都翻倍，`5`次的重试时间间隔为`1s`,` 2s`, `4s`, `8s`,` 16s`，总共`31s`，第`5`次发出后还要等`32s`都知道第`5`次也超时了，所以，总共需要 `1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s`，`TCP`才会断开这个连接。

这种处理方式会带来`SYN flood`攻击，即攻击者短时间内发送大量的`SYN`包给`server`，用于耗尽`server`的`SYN`队列，让正常连接请求无法处理。这时`netstat`可以看到大量的`SYN_RECV`状态。对于`SYN`过多的情况，`linux`提供了几个`TCP`参数来调整应对：

- `tcp_syncookies`(不推荐，违背了`TCP`协议)：当`SYN`队列满了之后，`TCP`会通过原地址端口、目标地址端口和时间戳生成一个特别的序列号(`cookie`)发回去，如果攻击者不会响应，而正常连接会把`SYN cookie`发送回来，服务端可以根据这个`cookie`进行连接，即使不在`SYN`队列中。
- `tcp_synack_retries`：减少重试次数
- `tcp_max_syn_backlog`：增大`SYN`队列，让服务器可以接受更多连接请求
- `tcp_abort_on_overflow`(谨慎设置) ：如果应用程序处理速度比较慢，来不及接受新的连接，系统就直接丢弃这个连接，给对端发个 `RST`。

### 四次挥手

主要包括以下几个步骤：

- `TCP`的`Peer`端在收到对端的`FIN`包前发出了`FIN`包，那么该`Peer`的状态就变成了`FIN_WAIT1`；

- `Peer`在`FIN_WAIT1`状态下收到对端`Peer`对自己`FIN`包的`ACK`包的话，那么`Peer`状态就变成`FIN_WAIT2`；

- `Peer`在`FIN_WAIT2`下收到对端`Peer`的`FIN`包，在确认已经收到了对端`Peer`全部的`Data`数据包后，就响应一个`ACK`给对端`Peer`，然后自己进入`TIME_WAIT`状态。
- 对端`Peer`收到`ACK`后/或者经过`2*MSL`后的等待，各自进入`CLOSED`，连接关闭。

实际上被动关闭方并没有数据要发送给主动关闭方时，将`FIN`和`ACK`合并成一个包发送过去，即只有三次挥手，也是可以的。四次挥手的原因是为了保证被动关闭方的数据也能够发送完毕。

#### 两端同时发起`FIN`

如果两边同时断开连接，会同时到达`CLOSING`状态，然后到达`TIME_WAIT`状态，等待`2*MSL`(最大存活时间)后连接真正关闭，即双方出现一样的状态转移：`FIN_WAIT1-->CLOSING->TIME_WAIT`。

![tcpclosesimul.png](/assets/tcpclosesimul.png)

#### `TIME_WAIT`

只有主动关闭方(在还没收到对方的`FIN`之前自己先发出了`FIN`)才会进入`TIME_WAIT`状态。需要`TIME_WAIT`的原因有：

-  在`ACK`丢失后，被动关闭方由于没有收到`ACK`，会进行重传。而此时主动关闭方已经关闭了，无法识别这个`FIN`包，会主动回复一个`RST`给被动关闭方，被动关闭方会收到错误(例如`connetion reset by peer`)，从而导致连接没有正常关闭而是发生了错误。
- 防止链路上已经关闭的残余数据包干扰正常的数据包。比如新的连接由于复用了上一个连接的五元素(源`IP`，目的`IP`，`TCP`，源端口，目的端口)，导致链路中残留的`FIN`包终止这次新的连接。

`Linux`将`MSL`时间固定为`30s`，因此`TIME_WAIT`需要等待`1分钟`。如果每秒的连接数是一千，那么一分钟可能会产生六万个`TIME_WAIT`。于是，大量的`TIME_WAIT`会消耗大量的系统资源。通常解决`TIME_WAIT`，会提及下面几个参数：

- `tcp_tw_recycle`：顾名思义就是回收`TIME_WAIT`连接，对客户端和服务器(服务端主动关闭连接)同时起作用。但是，当多个客户端通过`NAT`(对外是同一个`IP`)与服务端交互时，对于服务端事实上等同于同一个客户端，于是小时间戳的数据包会被丢弃，此时会有其他用户连接不上服务器。
- `tcp_tw_reuse`：当创建新连接的时候，如果可能的话会考虑复用相应的`TIME_WAIT`连接，只对连接发起方起作用(例如，客户端关闭连接又再次连接服务器；负载均衡服务器主动关闭对后端的连接，来了新的请求又再次连接)，且连接超过`1s`后才能被复用。通常认为它比`tcp_tw_recycle`安全一点。

需要注意的是，以上两者都依赖于`tcp_timestamps`，它在`linux`中是默认开启的。

除此之外，还有一个`tcp_max_tw_buckets`参数，用以控制并发的`TIME_WAIT`数量。采用`tcp_tw_recycle`和`tcp_tw_reuse`都是十分危险的，尽量将服务器设置为`KeepAlive`，把`TIME_WAIT`留给客户端去处理。

#### `CLOSE_WAIT`

主动关闭的一方发出`FIN`包，被动关闭的一方响应`ACK`包，此时，被动关闭的一方就进入了`CLOSE_WAIT`状态。如果一切正常，稍后被动关闭的一方也会发出`FIN`包，然后迁移到`LAST_ACK`状态。

当出现大量`CLOSE_WAIT`时，说明被动关闭一方没有及时发送`FIN`，可能是因为：

- 没有调用`socket`的`close`方法
- 响应太慢，导致`close`被延后
- `accept backlog`太大，来不及消费，多余请求被对方关闭

#### `LAST_ACK`

正常情况下，被动关闭方收到了主动关闭方最后发来的`ACK`后，会从`LAST_ACK`进入`CLOSED`状态。

如果被动关闭方没有收到`ACK`，当等待超时之后，它会继续向主动关闭方发送`FIN`包，那么会有下面的情况：

- 主动关闭方仍然处在`TIME_WAIT`，向被动关闭方发送`ACK`，这次被动关闭方终于收到了，于是进入了`CLOSED`
- 如果主动关闭方已经进入了`CLOSED`，那么它无法识别这个`FIN`，将会发送一个`RST`包，被动关闭方收到后进入`CLOSED`
- 如果被动关闭方一直没有收到`ACK`，那么它会重传到超时放弃，进入`CLOSED`

总而言之，最后都会进入`CLOSED`。

### `TCP`重传机制

接收端给发送端的`ACK`确认只会确认最后一个连续的包，那么当发送方没有收到刚发送的数据所的`ACK`时，等待超时后会选择重传，这就是超时重传。

当超时等待的`timeout`很长时，超时重传无疑是费时的。因此又引入了快速重传。就是在连续收到`3`次相同确认号的`ACK`，无需等待超时定时器溢出就进行重传。这个算法基于这么一个假设，连续收到`3`个相同的`ACK`，那么说明当前的网络状况变好了，可以重传丢失的包了。

但是这两种重传都没有解决是重传一个还是多个数据的问题，于是有了新的`SACK`机制。这种方式需要在`TCP`头里加一个`SACK`的东西(通过头中的可选选项扩展，`TCP`的选项不能超过`40`个字节，所以边界不能超过`4`组)，`ACK`还是`Fast Retransmit`的`ACK`，`SACK`则是汇报接收到的没有被确认的不连续数据段。接收方收到乱序包后，就会使用`SACK`选项来选择确认。参见下图：

![sack.jpg](/assets/tcp_sack_example-900x507.jpg)

而`D-SACK`是用`SACK`来告诉发送方，哪些数据被重复接收了，因此：

- `SACK`第一个段被`ACK`覆盖，那么是一个`D-SACK`
- `SACK`第一个段的范围被第二个段覆盖，也是一个`D-SACK`

它比`SACK`可以告知发送端更多的信息。

对于重传机制，`timeout`的设置十分重要，因此不能固定，所以引入了`RTT`(往返时延)，用以设置`RTO`(重传超时)。`RTT`算法的难点在于，是用正常发送和`ACK`回来的时间用于采样还是采用重传的时间和`ACK`回来的时间做样本。所以有了一个神一样的公式~

## `TCP`滑动窗口

`TCP`头中有个`Window`字段，**是接收端告诉发送端自己还有多少缓冲区可以接收数据**。**于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来**。如图：

![滑动窗口.jpg](/assets/tcpswflow.png)

发送端在窗口变成`0`后，会发`ZWP`的包给接收方，让接收方来`ack`他的`Window`尺寸，一般这个值会设置成`3`次，每次大约`30-60`秒（不同的实现可能会不一样）。如果`3`次过后还是`0`的话，有的`TCP`实现就会发`RST`把链接断了。

如果接收端处理有限，可能会导致发送大量小包的问题，即`Silly Window Syndrome`(糊涂窗口综合症)，此时可以从发送端和接收端来解决：

- 如果是接收端引起，当接收到数据小于某值时，就`ACK`一个`0`窗口，等到接收端处理了一些数据后`windows size` 大于等于了`MSS`，或者`buffer`有一半为空，就可以通告一个非`0`窗口。
- 如果是发送端引起，采用`Nagle’s algorithm`，默认是打开的，规则如下：
  - 如果包长度达到 `MSS` ，则允许发送；
  - 如果该包含有`FIN` ，则允许发送；
  - 设置了`TCP_NODELAY` 选项，则允许发送；
  - 设置`TCP_CORK`选项时，若所有发出去的小数据包(包长度小于`MSS`)均被确认，则允许发送；
  - 上述条件都未满足，但发生了超时(一般为`200ms` )，则立即发送。

> 可以在`Socket`设置`TCP_NODELAY`选项来关闭这个算法，并且它没有禁止小包发送，只是禁止了大量的小包发送。

## `TCP`拥塞处理

拥塞控制主要依赖于拥塞窗口(`cwnd`)来控制，再加上有接收窗口(`rwnd`)用于流量控制，因此实际的发送窗口为`min(rwnd, cwnd)`，包括了四个算法：

- 慢启动(`slow start`)：先线性后指数的算法

  - 连接建好的开始先初始化`cwnd = N`，表明可以传`N`个`MSS`大小的数据
  - 每当收到一个`ACK`，`++cwnd` ，呈线性上升
  - 每当过了一个`RTT`，`cwnd = cwnd*2`， 呈指数上升
  - 还有一个慢启动门限`ssthresh`(`slow start threshold`)，是一个上限，当`cwnd >= ssthresh`时，就会进入拥塞避免算法。

- 拥塞避免(`Congestion Avoidance`)：是一个线性上升的算法

  - 每收到一个`ACK`，调整`cwnd` 为 `(cwnd + 1/cwnd) * MSS`个字节
  - 每经过一个`RTT`的时长，`cwnd`增加`1`个`MSS`大小。

- 拥塞发生：当发生了丢包时，`TCP`认为网络发生了拥塞

  - 如果发生超时重传，反应比较强烈
    - 调整门限`ssthresh`的值为当前`cwnd`值的`1/2`；
    - `reset`自己的`cwnd`值为`1`；
    - 然后重新进入慢启动过程。
  - 如果发生快速重传，表明只是轻微拥堵，进入拥塞避免后，`cwnd`恢复的很慢，这时如果收到`3`个冗余的`ACK`时，那么进入的不是拥塞避免阶段，而是快速恢复
    - 调整门限`ssthresh`的值为当前`cwnd`值的`1/2`；
    - 将`cwnd`值设置为新的`ssthresh`的值；
    - 重新进入拥塞避免阶段。

- 快速恢复(`Fast Recovery`)：在进入快速恢复前，`cwnd` 和`sshthresh`已被更新为：`sshthresh = cwnd /2`，`cwnd = sshthresh`

  - 把`cwnd`设置为`ssthresh`的值加`3`，重传`Duplicated ACKs`指定的数据包
  - 如果再收到 `duplicated Acks`，那么`cwnd = cwnd +1`
  - 如果收到新的`ACK`，而非`Duplicated ACK`，那么`cwnd = sshthresh `，然后进入了拥塞避免算法

  > 显然，快速恢复依赖于`3`个重复的`ACK`，它只是重传了一个包，而如果还有其他的包丢失，只能等到超时重传，从而使得每超时一个窗口就减半，并且再也不会进入快速恢复阶段。出现这个问题的原因是过早退出了`Fast Recovery`阶段。

  为了解决快速恢复算法存在的问题，提出了`New Reno`算法，在没有`SACK`的支持下改进快速恢复算法:

  - 发送端收到`3`个冗余`ACK`后，重传冗余`ACK`指示可能丢失的那个包。如果只有这一个包丢了，那么重传这个包后回来的`ACK`会指示整个已经被出去的数据。如果没有的话，说明有多个包丢了。我们叫这个`ACK`为`Partial ACK`
  - 一旦发送端发现了`Partial ACK`出现，那么，`sender`就可以推理出来有多个包被丢了，于是乎继续重传滑动窗里未被`ACK`的第一个包。直到再也没有收到`Partial ACK`，才真正结束`Fast Recovery`这个过程

总而言之，拥塞避免时，`cwnd`是加性增长的，而出现了拥塞，是指数递减的。拥塞控制可以归纳为下图：

![拥塞控制](/assets/tcp.fr_-900x315.jpg)

## `TCP`和`UDP`的区别

- `UDP`不需要建立连接
- `UDP`的头只有`8`个字节，首部开销小
- `UDP`没有拥塞控制，网络拥塞不会使源主机发送速率降低
- `UDP`面向报文，会保留报文的边界，而`TCP`是面向字节流的，不保留边界，因此接发速率不一致时会出现粘包
- `TCP`提供可靠的服务,`TCP`连接传送的数据，无差错，不丢失，不重复，且按序到达；`UDP`尽最大努力交付，即不保证可靠交付
- 每一条`TCP`连接是点到点的，`UDP`支持一对一，一对多，多对一和多对多的交互通信

`References`:

[再叙TIME_WAIT](<https://huoding.com/2013/12/31/316>)

[浅谈CLOSE_WAIT](<https://huoding.com/2016/01/19/488>)

[高性能网络 | 你所不知道的TIME_WAIT和CLOSE_WAIT](<https://mp.weixin.qq.com/s?__biz=MzI4MjA4ODU0Ng==&mid=402415747&idx=1&sn=2458ba4fe1830eecdb8db725d3f395fa&scene=1&srcid=0317kixDKODOMBEMqjenW4Jb>)

[不为人知的网络编程(一)：浅析TCP协议中的疑难杂症(上篇)](<http://www.52im.net/thread-1003-1-1.html>)

[TCP 的那些事儿（上）](<https://coolshell.cn/articles/11564.html>)

[ TCP的那些事儿（下)](<https://coolshell.cn/articles/11609.html>)

[在tcp协议中处于last_ack状态的连接，如果一直收不到对方的ack，会一直处于这个状态吗？ - JCRunner的回答 - 知乎](https://www.zhihu.com/question/27564314/answer/162476313)