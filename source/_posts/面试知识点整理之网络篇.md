---
title: 面试知识点整理之网络篇
date: 2019-05-11 22:18:13
tags:
- web
categories:
- Web
---

面试时所必要，或者被问到的问题的记录，如果有理解错误或者疏漏，烦请指出，万分感谢：）

## `TCP`三次握手与四次挥手

1. 为何需要四次挥手
2. 出现大量`TIME_WAIT`应当如何处理
3. `SYN FLOOD`出现原因及原理

<!-- more-->

## 浏览器中输入`url`到显示主页的过程

1. 输入`url`
2. `DNS`解析：浏览器缓存->操作系统缓存->`hosts`文件->路由器缓存->`ISP DNS`缓存->顶级`DNS`->根`DNS`，向找到的域名服务器发起请求，将结果返回给用户，并且缓存下来
3. 建立`TCP`连接
4. 发送`HTTP`请求
5. 服务器处理请求
6. 服务器返回响应
7. 浏览器渲染
8. 连接结束
9. 涉及到`HTTP`协议，`TCP`协议、`IP`协议和`DNS`协议等

## `TCP`如何保证可靠传输

建立连接前，需要三次握手。数据传送时，有确认、重传、流量控制和拥塞控制机制。

## `HTTP`和`HTTPS`的区别

所谓`HTTPS`, 其实就是身披`SSL`协议的这层外壳的`HTTP`。`HTTPS`采用混合加密机制，即交换密钥环节使用非对称加密方式，生成了会话密钥后，使用对称加密方式加密内容。

`HTTPS`有如下特点：

- 生成对话密钥总共需要三个随机数
- 握手之后的对话使用对话密钥(对称加密)，服务器的公钥和私钥只用于加密和解密对话密钥(非对称加密)，无其他作用
- 服务器公钥放在服务器的数字证书之中。只要证书是可信的，公钥就是可信的。
- 整个握手阶段都不加密，只取决于`premaster secret`(第三个随机数)是否能被破解

所以两者区别主要有：

1. `HTTP`协议需要到`ca`申请证书，一般免费证书较少，因而需要一定费用。
2. `HTTP`是超文本传输协议，信息是明文传输，`HTTPS`则是具有安全性的`SSL`加密传输协议。
3. `HTTP`和`HTTPS`使用的是完全不同的连接方式，用的端口也不一样，前者是`80`，后者是`443`。
4. `HTTP`的连接很简单，是无状态的；`HTTPS`协议是由`SSL+HTTP`协议构建的可进行加密传输、身份认证的网络协议，比`HTTP`协议安全。

## `TCP`和`UDP`协议的区别

主要分为是否面向连接，传输是否可靠，传输形式是报文还是字节流，以及传输效率，所需资源，应用场景和首部字节几个方面。

其中`HTTP`、`HTTPS`、`SMTP`、`POP3`、`FTP`、`TELNET`等是基于`TCP`的应用层协议。

`DHCP`(动态获取`IP`地址，缺省网关等)、使用的是`UDP`的应用协议。

`DNS`是基于`TCP/UDP`的应用层协议。

## 常见的状态码

- 1xx，请求正在被处理

- 2xx，请求处理成功

  - 200，请求被成功处理

  - 204，请求被成功处理，但响应的主体部分为空，适用于只需要客户端向服务端发送数据的情况(使用`DELETE`时返回204)
  - 206，客户端进行了部分请求，服务端返回指定部分的内容

- 3xx，需要重定向

  - 301，请求的资源被分配了新的URL，永久重定向

  - 302，请求的资源被分配了新的URL，暂时重定向
  - 303，同302，区别在于服务端要求客户端使用`GET`方法请求新的`URL`
  - 304，客户端进行附带条件的请求时，允许访问资源，但没满足条件，与重定向没有任何关系

- 4xx，客户端错误或请求无法实现

  - 400，`Bad Request`，客户端请求有语法错误

  - 401，`Unauthorized`，请求未经授权
  - 403，`Forbidden`，请求的资源被服务器拒绝
  - 404，`Not Found`，服务器上没有请求的资源

- 5xx，服务器端错误，未能实现合法请求

  - 500，服务器在处理请求时出现了错误

  - 503，服务器处于超负荷或维护状态，无法处理请求

`301`和`302`的区别：

- 302重定向是暂时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。 容易被网址劫持，导致网站降权。
- 301重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。

## `HTTP`长连接和短连接

`HTTP/1.0`默认使用短连接，客户端和服务器每进行一次`HTTP`操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个`HTML`或其他类型的`Web`页中包含有其他的`Web`资源（如`JavaScript`文件、图像文件、`CSS`文件等），每遇到这样一个`Web`资源，浏览器就会重新建立一个`HTTP`会话。

从`HTTP/1.1`起，默认使用长连接。响应头会加入：

```html 
Connection:keep-alive
```

一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。长连接情况下，客户端和服务器之间用于传输`HTTP`的`TCP`连接不会关闭，再次访问服务器时会复用该连接。它并不是永久保持连接，具有一个保持时间，并且需要客户端和服务器都支持长连接。

## `cookie`和`session`的区别

- `cookie`中只能保存`ascii`字符串，但是`session`可以存取任何类型的数据
- `cookie`存储在客户端本地中，对客户端是可见的，其他程序可能会窥探、复制甚至修改；而`session`存储在服务器中，不存在敏感信息泄露的风险
- `cookie`可以带来更长有效期的登录状态的保持，而`session`只要关闭了浏览器则会失效(随着存储在浏览器进程中的会话`cookie`的消失而消失，并不是服务器端主动删除)，如果超时时间过长，会导致服务器内存溢出
- `cookie`保管在客户端，不占用服务器资源；`session`存储在服务器端，并发量高的时候容易耗费大量的内存，给服务器带来巨大的压力
- `cookie`需要浏览器的支持，如果浏览器不支持`cookie`，需要运用`session`以及`URL`地址重写。`cookie`既支持本浏览器窗口以及子窗口内有效，也能够设为一些浏览器窗口有效。但是`session`只能在此次浏览器或者其子窗口有效。
- `cookie`支持跨域访问；`session`仅在所在域名有效。

## `HTTP`的报文格式

`HTTP`请求报文由请求行、请求头部、空行(回车+换行)和请求正文组成。

`HTTP`响应报文由状态航、消息报头、空行和响应正文组成。

## `HTTP`请求方法

- `GET`： 获取资源
- `POST`：传输实体主体，并返回处理数据后的结果
- `PUT`：传输文件
- `HEAD`：获得报文首部，只是获取的是报文首部，用来确定客户端输入的`URI`的有效性和资源更新的日期时间
- `DELETE`：删除文件
- `OPTIONS`：询问服务器支持哪种方法
- `TRACE`：回显服务器收到的请求，主要用于测试和诊断
- `CONNECT`：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器
- `PATCH`: 一般用于资源的部分更新，而`PUT`一般用于资源的整体更新。 当资源不存在时，`PATCH`会创建一个新的资源，而`PUT`只会对已存在资源进行更新。

## `GET`和`POST`的区别

- `GET`语义上是幂等的，`POST`不是

- `GET`提交，请求的数据会附在`URL`之后，`POST`提交是将提交的数据放置在`HTTP`包的包体中。因此，`GET`提交的数据会在地址栏中显示出来，而`POST`提交，地址栏不会改变。
- 虽然`HTTP`协议没有对传输的数据大小进行限制，`HTTP`协议规范也没有对`URL`长度进行限制，但是由于特定浏览器和服务器对`URL`长度有限制，因此`GET`提交时，传输数据就会受到`URL`长度的限制。而`POST`提交不是通过`URL`传值，理论上数据不受限，但实际各个`WEB`服务器会规定对`POST`提交数据大小进行限制。
- 通过`GET`提交数据，用户名和密码将出现在`URL`中，带来很大的安全隐患，除此之外，还可能会造成`CSRF`攻击。

## `XSS`和`CSRF`的区别

`xss`原理上市利用`js`脚本注入，从而达到盗取用户`Cookie`、破坏页面结构、重定向到其它网站等攻击手段。

而`csrf`原理上利用的是网站服务器端参数可预先构造的原理，拼接构造好`url`，引用用户提交请求。

`xss`防范方法：

- 使用`HttpOnly`防止`js`获取`cookie`，这个标记是在服务器端向客户端发送`set-cookie`时标记的
- 需要对用户的输入进行处理，只允许输入合法的值，其它值一概过滤掉。

`csrf`防范方法：

本质是要求网站能够识别出哪些请求是非正常用户主动发起的。因此需要在请求中嵌入一些额外的授权数据，让网站服务器能够区分出这些未授权的请求。可以利用：

1. `GET` 请求不对数据进行修改
2. 不让第三方网站访问到用户`Cookie`
3. 阻止第三方网站请求接口
4. 请求时附带验证信息，比如验证码或者`token`

## 为什么会有`OPTIONS`请求

`OPTIONS`的用途主要有：

- 获取服务器支持的`HTTP`请求
- 用来检查服务器的性能，例如`AJAX`进行跨域请求时的预检，需要向另外一个域名的资源发送一个`HTTP OPTIONS`请求头，用以判断实际发送的请求是否安全。

一般都是浏览检测到请求跨域时，会自动发起预检请求，以检测实际请求是否可以被服务器所接受。预检请求报文中的`Access-Control-Request-Method`首部字段告知服务器实际请求所使用的`HTTP`方法；`Access-Control-Request-Headers`首部字段告知服务器实际请求所携带的自定义首部字段。服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求。

当满足下面任意一个条件(即非简单请求)时，浏览器会发送`OPTIONS`请求：

- 请求方法不是`GET/HEAD/POST`之一
- 请求头的`Content-Type`不是下列之一：
  - `application/x-www-form-urlencoded`
  - `multipart/form-data`
  - `text/plain`
- 人为设置了[对 CORS 安全的首部字段集合](https://fetch.spec.whatwg.org/#cors-safelisted-request-header)之外的其他首部字段

## 同源和跨域

所谓同源是指：

- 协议相同
- 域名相同
- 端口相同

`CORS`可以允许浏览器向跨源服务器发出请求，从而克服了`AJAX`只能[同源](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)使用的限制。需要服务器和浏览器同时支持，不需要用户参与，所有浏览器都支持，因此只要服务器实现了`CORS`，就可以跨源通信。

## 加密方式

### 对称加密和非对称加密

根据密钥类型不同将现代密码技术分为两类：对称加密算法和非对称加密算法。

对称加密，常用的有`DES`、`3DES`、`AES`，特点有：

1. 加密方和解密方使用同一个密钥。
2. 加密解密的速度比较快，适合数据比较长时的使用。
3. 密钥传输的过程不安全，且容易被破解，密钥管理也比较麻烦。

非对称加密，加密密钥(公钥)和解密密钥(私钥)是不同的。常见的有`RSA`、`DSA`。

总结：

- 由于非对称加密算法的运行速度比对称加密算法的速度慢很多，当我们需要加密大量的数据时，建议采用对称加密算法，提高加解密速度。
- 对称加密算法不能实现签名，因此签名只能非对称算法。
- 由于对称加密算法的密钥管理是一个复杂的过程，密钥的管理直接决定着他的安全性，因此当数据量很小时，我们可以考虑采用非对称加密算法。

在实际的操作过程中，我们通常采用的方式是：**采用非对称加密算法管理对称算法的密钥，然后用对称加密算法加密数据**。这样我们就集成了两类加密算法的优点，既实现了加密速度快的优点，又实现了安全方便管理密钥的优点。

### 单向加密

另外还存在单向加密算法，散列算法，主要有：

- `MD5`：实际上是摘要算法，无论多长都会输出`128bits`的摘要
- `SHA1`：安全性更强，会产生一个`160bits`的摘要

单向加密算法不可逆，用在检查数据完整性以及数字签名场景中。

比方说，服务器方将内容使用散列算法，生成摘要。然后再使用服务器端的私钥对摘要进行加密，生成数字签名。客户端接收到内容后，使用服务证书中的公钥对数字签名进行解密，获得摘要，再将内容通过散列算法生成的摘要进行比对，从而证明内容来自于服务器并且并未被修改过。

===========2019年05月17日11:18:09更新分割==============

## `HTTP1.0`/`HTTP1.1`/`HTTP2.0`的区别

[HTTP1.0、HTTP1.1 和 HTTP2.0 的区别](https://juejin.im/entry/5981c5df518825359a2b9476)

首先是`HTTP1.0`和`HTTP1.1`的区别：

- 缓存处理，`HTTP1.1`引入了更多的缓存控制策略，例如`Entity tag`、`If-Unmodified-Since`、 `If-Match`、` If-None-Match`等。
- 带宽优化及网络连接的使用：`HTTP1.1`在请求头引入了`range`域，支持断点续传
- 错误通知的管理：新增了24个错误状态响应码
- `Host`头处理：`HTTP1.1`支持`Host`头域，使得浏览器可以向一台物理服务器上的多个虚拟主机发起请求
- 长连接

`HTTP2.0`相比`HTTP1.X`的新特性：

- 新的二进制格式：`HTTP1.X`的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制格式，实现方便且健壮。
- 多路复用：连接共享，一个`request`对应一个`id`，这样一个连接上可以有多个`request`，每个连接的`request`可以随机的混杂在一起，接收方可以根据`request`的 `id`将`request`再归属到各自不同的服务端请求里面。
- `header`压缩：`HTTP1.X`的`header`带有大量信息，而且每次都要重复发送，`HTTP2.0`使用encoder来减少需要传输的`header`大小，通讯双方各自`cache`一份`header fields`表，既避免了重复`header`的传输，又减小了需要传输的大小。
- 服务端推送：例如网页有一个`sytle.css`的请求，在客户端收到`sytle.css`数据的同时，服务端会将`sytle.js`的文件推送给客户端，省去了客户端重复请求的步骤。

> 多路复用和长连接复用的区别在于：长连接复用是若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会；而多路复用可以使得多个请求在同一个连接上并行执行，某个请求耗时严重并不会影响其他请求。

## 如何验证`HTTPS`证书的合法性

[浏览器如何验证HTTPS证书的合法性？](https://www.zhihu.com/question/37370216)

1. 浏览器内置了信任的根证书，进行`SSL`握手时，服务器端会返回自己的证书
2. 拿到证书后验证其数字签名。具体就是，根据证书上写的`CA`签发机构，在浏览器内置的根证书里找到对应的公钥，用此公钥解开数字签名，得到摘要（`digest`,证书内容的`hash`值），据此验证证书的合法性。
3. 如果验证失败，会尝试查询证书吊销列表(`CRL`)和在线证书检查(`OCSP`)

====================2019年05月22日17:19:49更新=============

## 如何设计可靠的`udp`协议

[怎么让不可靠的 UDP 可靠？](https://www.infoq.cn/article/how-to-make-udp-reliable)

1. 如果要可靠的话，需要增加`seq/ack`机制(业务层），确保数据发送到对端。

2. 增加发送和接收缓冲区，实现重传。重传方案有：

- 定时重传：超过`RTO`时间，则进行重传，适用于小带宽低延迟(将`RTO`设计的很小)
- 请求重传：后续`ACK`携带丢失包信息，适用于带宽较大的传输场景
- `FEC`选择重传：会发送一些冗余包，可以通过`FEC`进行恢复，适合演示敏感且随机丢包的传输场景

增加了重传可能会带来网络风暴，所以必要的时候可以设计窗口进行拥塞处理。如果需要数据严格有序，接收端还应该做好窗口排序和缓冲。

## `OSI`模型与`TCP/IP`协议

`OSI`总共有七层，分别是物理层，数据链路层，网络层，传输层，会话层，表示层和应用层。

`TCP/IP`模型分为了四层，分别是链路层，网络层，传输层和应用层。

## `IP`地址分类

32位`IP`地址分为网络位和地址位，分为`A`、`B`、`C`三类以及特殊地址`D`和`E`：

```shell 
A类地址
  0.  0.  0.  0 = 00000000.00000000.00000000.00000000
127.255.255.255 = 01111111.11111111.11111111.11111111
    		子网掩码 = 255.0.0.0       
B类地址
128.  0.  0.  0 = 10000000.00000000.00000000.00000000
191.255.255.255 = 10111111.11111111.11111111.11111111
        子网掩码 = 255.255.0.0
C类地址
192.  0.  0.  0 = 11000000.00000000.00000000.00000000
223.255.255.255 = 11011111.11111111.11111111.11111111
				子网掩码 = 255.255.255.0
D类地址
224.  0.  0.  0 = 11100000.00000000.00000000.00000000
239.255.255.255 = 11101111.11111111.11111111.11111111

E类地址
240.  0.  0.  0 = 11110000.00000000.00000000.00000000
255.255.255.255 = 11111111.11111111.11111111.11111111
```

## 各层的协议

网络层：

- `ARP`/`RARP`
- `ICMP`：`ping`和`traceroute`都是基于此的工具

传输层：

- `TCP`：`SMTP`/`TELNET`/`HTTP`/``FTP
- `UDP`：`TFTP`/`SNMP`/`NFS`

## 有了`IP`地址，为什么还需要`MAC`地址

1. 优点：可以根据`IP`划分子网，方便路由
2. 必要性：`IP`层也需要物理根基，因特网离不开以太网

## 集线器、交换机和路由器，网卡

集线器工作在物理层

交换机工作在链路层，通过`MAC`地址传送信息

路由器工作在网络层，存在路由表进行`IP`寻址

网卡的作用将数据封装成帧，通过网线发送出去；将帧组合成数据，发送给计算机，工作在数据链路层。