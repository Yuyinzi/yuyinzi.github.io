---
title: 面试知识点整理之网络篇
date: 2019-05-11 22:18:13
tags:
- web
categories:
- Web
---

## TCP`三次握手与四次挥手

1. 为何需要四次挥手
2. 出现大量`TIME_WAIT`应当如何处理

<!-- more-->

## 浏览器中输入`url`到显示主页的过程

1. 输入`url`
2. DNS`解析：浏览器缓存->操作系统缓存->`hosts`文件->路由器缓存->`ISP DNS`缓存->顶级`DNS`->根`DNS`，向找到的域名服务器发起请求，将结果返回给用户，并且缓存下来
3. 建立`TCP`连接
4. 发送`HTTP`请求
5. 服务器处理请求
6. 服务器返回响应
7. 浏览器渲染
8. 连接结束
9. 涉及到`HTTP`协议，`TCP`协议、`IP`协议和`DNS`协议等

## `TCP`如何保证可靠传输

建立连接前，需要三次握手。数据传送时，有确认、重传、流量控制和拥塞控制机制。

## `HTTP`和`HTTPS`的区别

所谓`HTTPS`, 其实就是身披`SSL`协议的这层外壳的`HTTP`。`HTTPS`采用混合加密机制，即交换密钥环节使用非对称加密方式，生成了会话密钥后，使用对称加密方式加密内容。

`HTTPS`有如下特点：

- 生成对话密钥总共需要三个随机数
- 握手之后的对话使用对话密钥(对称加密)，服务器的公钥和私钥只用于加密和解密对话密钥(非对称加密)，无其他作用
- 服务器公钥放在服务器的数字证书之中。只要证书是可信的，公钥就是可信的。
- 整个握手阶段都不加密，只取决于`premaster secret`(第三个随机数)是否能被破解

所以两者区别主要有：

1. `HTTP`协议需要到`ca`申请证书，一般免费证书较少，因而需要一定费用。
2. `HTTP`是超文本传输协议，信息是明文传输，`HTTPS`则是具有安全性的`SSL`加密传输协议。
3. `HTTP`和`HTTPS`使用的是完全不同的连接方式，用的端口也不一样，前者是`80`，后者是`443`。
4. `HTTP`的连接很简单，是无状态的；`HTTPS`协议是由`SSL+HTTP`协议构建的可进行加密传输、身份认证的网络协议，比`HTTP`协议安全。

## `TCP`和`UDP`协议的区别

主要分为是否面向连接，传输是否可靠，传输形式是报文还是字节流，以及传输效率，所需资源，应用场景和首部字节几个方面。

## 常见的状态码

- 1xx，请求正在被处理

- 2xx，请求处理成功

  - 200，请求被成功处理

  - 204，请求被成功处理，但响应的主体部分为空，适用于只需要客户端向服务端发送数据的情况(使用`DELETE`时返回204)
  - 206，客户端进行了部分请求，服务端返回指定部分的内容

- 3xx，需要重定向

  - 301，请求的资源被分配了新的URL，永久重定向

  - 302，请求的资源被分配了新的URL，暂时重定向
  - 303，同302，区别在于服务端要求客户端使用`GET`方法请求新的`URL`
  - 304，客户端进行附带条件的请求时，允许访问资源，但没满足条件，与重定向没有任何关系

- 4xx，客户端错误或请求无法实现

  - 400，`Bad Request`，客户端请求有语法错误

  - 401，`Unauthorized`，请求未经授权
  - 403，`Forbidden`，请求的资源被服务器拒绝
  - 404，`Not Found`，服务器上没有请求的资源

- 5xx，服务器端错误，未能实现合法请求

  - 500，服务器在处理请求时出现了错误

  - 503，服务器处于超负荷或维护状态，无法处理请求

`301`和`302`的区别：

- 302重定向是暂时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。 容易被网址劫持，导致网站降权。
- 301重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。

## `HTTP`长连接和短连接

`HTTP/1.0`默认使用短连接，客户端和服务器每进行一次`HTTP`操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个`HTML`或其他类型的`Web`页中包含有其他的`Web`资源（如`JavaScript`文件、图像文件、`CSS`文件等），每遇到这样一个`Web`资源，浏览器就会重新建立一个`HTTP`会话。

从`HTTP/1.1`起，默认使用长连接。响应头会加入：

```html 
Connection:keep-alive
```

长连接情况下，客户端和服务器之间用于传输`HTTP`的`TCP`连接不会关闭，再次访问服务器时会复用该连接。它并不是永久保持连接，具有一个保持时间，并且需要客户端和服务器都支持长连接。

## `cookie`和`session`的区别

- `cookie`中只能保存`ascii`字符串，但是`session`可以存取任何类型的数据
- `cookie`存储在客户端本地中，对客户端是可见的，其他程序可能会窥探、复制甚至修改；而`session`存储在服务器中，不存在敏感信息泄露的风险
- `cookie`可以带来更长有效期的登录状态的保持，而`session`只要关闭了浏览器则会失效(随着存储在浏览器进程中的会话`cookie`的消失而消失，并不是服务器端主动删除)，如果超时时间过长，会导致服务器内存溢出
- `cookie`保管在客户端，不占用服务器资源；`session`存储在服务器端，并发量高的时候容易耗费大量的内存，给服务器带来巨大的压力
- `cookie`需要浏览器的支持，如果浏览器不支持`cookie`，需要运用`session`以及`URL`地址重写。`cookie`既支持本浏览器窗口以及子窗口内有效，也能够设为一些浏览器窗口有效。但是`session`只能在此次浏览器或者其子窗口有效。
- `cookie`支持跨域访问；`session`仅在所在域名有效。

## `HTTP`的报文格式

`HTTP`请求报文由请求行、请求头部、空行(回车+换行)和请求正文组成。

`HTTP`响应报文由状态航、消息报头、空行和响应正文组成。

## `HTTP`请求方法

- `GET`： 获取资源
- `POST`：传输实体主体，并返回处理数据后的结果
- `PUT`：传输文件
- `HEAD`：获得报文首部，只是获取的是报文首部，用来确定客户端输入的`URI`的有效性和资源更新的日期时间
- `DELETE`：删除文件
- `OPTIONS`：询问服务器支持哪种方法
- `TRACE`：回显服务器收到的请求，主要用于测试和诊断
- `CONNECT`：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器
- `PATCH`: 一般用于资源的部分更新，而`PUT`一般用于资源的整体更新。 当资源不存在时，`PATCH`会创建一个新的资源，而`PUT`只会对已存在资源进行更新。

## `GET`和`POST`的区别

- `GET`语义上是幂等的，`POST`不是

- `GET`提交，请求的数据会附在`URL`之后，`POST`提交是将提交的数据放置在`HTTP`包的包体中。因此，`GET`提交的数据会在地址栏中显示出来，而`POST`提交，地址栏不会改变。
- 虽然`HTTP`协议没有对传输的数据大小进行限制，`HTTP`协议规范也没有对`URL`长度进行限制，但是由于特定浏览器和服务器对`URL`长度有限制，因此`GET`提交时，传输数据就会受到`URL`长度的限制。而`POST`提交不是通过`URL`传值，理论上数据不受限，但实际各个`WEB`服务器会规定对`POST`提交数据大小进行限制。
- 通过`GET`提交数据，用户名和密码将出现在`URL`中，带来很大的安全隐患，除此之外，还可能会造成`CSRF`攻击。

## `XSS`和`CSRF`的区别

`xss`原理上市利用`js`脚本注入，从而达到盗取用户`Cookie`、破坏页面结构、重定向到其它网站等攻击手段。

而`csrf`原理上利用的是网站服务器端参数可预先构造的原理，拼接构造好`url`，引用用户提交请求。

`xss`防范方法：

- 使用`HttpOnly`防止`js`获取`cookie`，这个标记是在服务器端向客户端发送`set-cookie`时标记的
- 需要对用户的输入进行处理，只允许输入合法的值，其它值一概过滤掉。

`csrf`防范方法：

本质是要求网站能够识别出哪些请求是非正常用户主动发起的。因此需要在请求中嵌入一些额外的授权数据，让网站服务器能够区分出这些未授权的请求。可以利用：

1. `GET` 请求不对数据进行修改
2. 不让第三方网站访问到用户`Cookie`
3. 阻止第三方网站请求接口
4. 请求时附带验证信息，比如验证码或者`token`

## 为什么会有`OPTIONS`请求

`OPTIONS`的用途主要有：

- 获取服务器支持的`HTTP`请求
- 用来检查服务器的性能，例如`AJAX`进行跨域请求时的预检，需要向另外一个域名的资源发送一个`HTTP OPTIONS`请求头，用以判断实际发送的请求是否安全。

一般都是浏览检测到请求跨域时，会自动发起预检请求，以检测实际请求是否可以被服务器所接受。预检请求报文中的`Access-Control-Request-Method`首部字段告知服务器实际请求所使用的`HTTP`方法；`Access-Control-Request-Headers`首部字段告知服务器实际请求所携带的自定义首部字段。服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求。

当满足下面任意一个条件(即非简单请求)时，浏览器会发送`OPTIONS`请求：

- 请求方法不是`GET/HEAD/POST`之一
- 请求头的`Content-Type`不是下列之一：
  - `application/x-www-form-urlencoded`
  - `multipart/form-data`
  - `text/plain`
- 人为设置了[对 CORS 安全的首部字段集合](https://fetch.spec.whatwg.org/#cors-safelisted-request-header)之外的其他首部字段

## 同源和跨域

所谓同源是指：

- 协议相同
- 域名相同
- 端口相同

`CORS`可以允许浏览器向跨源服务器发出请求，从而克服了`AJAX`只能[同源](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)使用的限制。需要服务器和浏览器同时支持，不需要用户参与，所有浏览器都支持，因此只要服务器实现了`CORS`，就可以跨源通信。

## 加密方式

### 对称加密和非对称加密

根据密钥类型不同将现代密码技术分为两类：对称加密算法和非对称加密算法。

对称加密，常用的有`DES`、`3DES`、`AES`，特点有：

1. 加密方和解密方使用同一个密钥。
2. 加密解密的速度比较快，适合数据比较长时的使用。
3. 密钥传输的过程不安全，且容易被破解，密钥管理也比较麻烦。

非对称加密，加密密钥(公钥)和解密密钥(私钥)是不同的。常见的有`RSA`、`DSA`。

总结：

- 由于非对称加密算法的运行速度比对称加密算法的速度慢很多，当我们需要加密大量的数据时，建议采用对称加密算法，提高加解密速度。
- 对称加密算法不能实现签名，因此签名只能非对称算法。
- 由于对称加密算法的密钥管理是一个复杂的过程，密钥的管理直接决定着他的安全性，因此当数据量很小时，我们可以考虑采用非对称加密算法。

在实际的操作过程中，我们通常采用的方式是：**采用非对称加密算法管理对称算法的密钥，然后用对称加密算法加密数据**。这样我们就集成了两类加密算法的优点，既实现了加密速度快的优点，又实现了安全方便管理密钥的优点。

### 单向加密

另外还存在单向加密算法，散列算法，主要有：

- `MD5`：实际上是摘要算法，无论多长都会输出`128bits`的摘要
- `SHA1`：安全性更强，会产生一个`160bits`的摘要

单向加密算法不可逆，用在检查数据完整性以及数字签名场景中。

比方说，服务器方将内容使用散列算法，生成摘要。然后再使用服务器端的私钥对摘要进行加密，生成数字签名。客户端接收到内容后，使用服务证书中的公钥对数字签名进行解密，获得摘要，再将内容通过散列算法生成的摘要进行比对，从而证明内容来自于服务器并且并未被修改过。