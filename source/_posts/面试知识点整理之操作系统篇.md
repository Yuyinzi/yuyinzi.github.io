---
title: 面试知识点整理之操作系统篇
date: 2019-05-16 15:58:01
tags:
- 操作系统
categories:
- 操作系统
---

## 用户态和内核态

现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核(`kernel`），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为**内核空间**，一部分为**用户空间**。针对`linux`操作系统而言，将最高的1G字节(从虚拟地址`0xC0000000`到`0xFFFFFFFF`)，供内核使用，称为内核空间，而将较低的3G字节(从虚拟地址`0x00000000`到`0xBFFFFFFF`)，供各个进程使用，称为用户空间。

在用户态下，`CPU`只能访问用户空间内存；当在内核态时，`CPU`既可以访问用户空间也可以访问内核空间。

<!-- more -->

## 堆和栈的区别

- 栈由系统编译器管理，堆需要手动管理，及时释放
- 栈地址从高向低扩展，是连续的；堆地址从低向高扩展，是不连续的

## 进程和线程的区别

**两个名词不过是对应的CPU时间段的描述：**

**进程就是包换上下文切换的程序执行时间总和** = **CPU加载上下文+CPU执行+CPU保存上下文**。而**线程是共享了进程的上下文环境，的更为细小的CPU时间段**。

1. 进程是系统进行资源调度和分配的独立单位，具有独立的地址空间(也称为段)。从上而下包括，栈，堆，未初始化变量区(`BSS`)，初始化变量区(数据段)，以及代码段。
2. 线程间的数据通信更为简单
3. 创建线程的速度要快于创建进程
4. 进程的隔离性更好，一个线程的问题可能会影响同一进程内的所有线程
5. 每个线程都在征用进程中有限的虚拟地址空间，而进程可以使用全部有效虚拟内存
6. 线程共享进程的虚拟地址空间（共享段、数据段）、用户ID和组ID、文件描述符表、当前工作目录、但是线程也拥有属于自己的栈，用来装载本地变量和函数调用链接信息。

## 线程同步

线程可以使用下面两个工具来同步彼此行为：

- 互斥量：保证资源不会被多个线程同时访问

- 条件变量：通知操作的方式保持多线程同步

并且条件变量总是与互斥量相关。

## 进程间通信

[进程间通信IPC (InterProcess Communication)](https://www.jianshu.com/p/c1015f5ffa74)

工具包括匿名管道，命名管道，消息队列，信号，共享内存，信号量，`socket`。

- 管道是一种半双工的通信方式，数据只能**单向**流动，并且只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程

- 命名管道也是半双工的通信方式，但它允许无亲缘关系的进程间进行通信

- 信号可以在任何时候发给某一进程，而无需知道该进程的状态，是软件层次上对终端机制的模拟。常用的有

  - `SIGHUP`：用户从终端注销，所有已启动进程都将收到该信号。系统缺省状态下对该信号的处理是终止进程。
  - SIGINT：程序终止信号。程序运行过程中，按`Ctrl+C`键将产生该信号。
  - `SIGQUIT`：程序退出信号。
  - `SIGBUS和SIGSEGV`：进程访问非法地址。
  - `SIGFPE`：运算中出现致命错误，如除零操作、数据溢出等。
  - `SIGKILL`：用户终止进程执行信号。`shell`下执行`kill -9`发送该信号。
  - `SIGTERM`：结束进程信号。shell下执行`kill 进程pid`发送该信号。
  - `SIGALRM`：**定时器信号。**
  - `SIGCLD`：子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。

- 消息队列是消息的链表，存放在**内核**中并由消息队列标识符标识，与管道不同的还有，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。但是它们都是先进先出的。

- 共享内存是内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。多个进程可以可以直接读写同一块内存空间，是最快的可用`IPC`形式。当某进程改变了共享内存的内容，其他所有进程会立即了解到这一变化。

- 信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。

  > **信号量与互斥量之间的区别：**
  >  （1）互斥量用于线程的互斥，信号量用于线程的同步。
  >  **互斥：**是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。
  >  **同步：**是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。
  >  （2）互斥量值只能为0/1，信号量值可以为非负整数。一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量时，也可以完成一个资源的互斥访问。
  >  （3）互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。

- `socket`：可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。

> 信号量和文件锁可以用于同步。互斥量和条件变量通常用于线程同步。

## 进程的状态

- 就绪状态，等待`CPU`。也可以细分为活跃就绪(进程在主存中可以被调度)和静止就绪(进程被对换到辅存时，不能被调度)。
- 运行状态，已获得`CPU`
- 阻塞状态，例如请求`I/O`，申请缓冲空间。与就绪类似的也可以细分为活跃阻塞和静止阻塞。

此外还有：

- 创建状态：进程还在被创建，尚未到就绪状态
- 结束状态

## 什么是死锁，如何解决

产生死锁的条件有四个：

1. 互斥条件：所谓互斥就是进程在某一时间内独占资源。 
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
3. 不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。 
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

死锁预防：破坏任意一个必要条件就可以预防死锁。例如，以一定顺序获得锁，或者一次申请全部的资源，以及超时放弃锁。

死锁避免：每次申请资源时判断操作是否安全。[银行家算法]([http://chuxiuhong.com/2016/11/26/1%20(5)/](http://chuxiuhong.com/2016/11/26/1 (5)/)

死锁检测：判断系统是否处于死锁状态。资源分配图。

死锁解除：

- 剥夺，将某进程资源强行收回，分配给其他进程。
- 撤销进程

## 分页和分段

[进程地址空间与虚拟存储空间的理解](https://blog.csdn.net/do2jiang/article/details/4690967)

段和页用来解决：

1. 进程地址空间不隔离
2. 内存使用效率低
3. 程序运行地址不确定

因此增加了一个中间层，使用虚拟地址映射到物理地址的方式进行访问。这样对于程序来说，只需要关注虚拟地址。即使虚拟地址一样，对于不同的进程来说，仍然可以保证不同程序最终访问内存地址位于不同区域，用以解决1和3的问题。此时，引入分段的思想，在虚拟地址空间和物理地址空间做一一映射。

而分页用以解决每次换入内存过大的问题2，即用更小粒度的内存分隔和映射方法。当`CPU`访问程序中用到的虚拟地址时，发现没有对应的物理地址，会引发一个页错误。此时由操作系统建立映射，并由`CPU`重新执行。因此，随着程序执行，页错误会不断产生，操作系统也会分配相应的物理页来满足执行需求。

另外，当内存不足发生页错误时(缺页中断)，操作系统会在内存选择一个页面移出内存，称为页面置换算法。

**虚拟内存将主存看成是一个磁盘的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。**

[什么是内存(二)：虚拟内存](https://www.cnblogs.com/yaoxiaowen/p/7805964.html)

分页与分段管理的比较：

- 页是信息的**物理单位**，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率。段则是信息的**逻辑单位**，它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。
- 页的大小固定且由系统决定；而段的长度却不固定，决定于用户所编写的程序。
- 分页的地址空间是一维的，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。

## 页面置换算法

- 最佳置换算法(理想情况下)：有些页面在内存中，知道其中有一页将很快被访问，其他页面会在执行10、100或者1000条指令才会被访问，那么将1000条指令的页面(最大标记数)置换出去。虽然不可实现，可以用来对算法进行衡量。
- 先进先出置换算法：选择在主存中停留时间最长的页置换出去
- 最近最久未使用(`LRU`)算法：选择最近一段时间里没有使用过的页面予以置换
- `clock`算法
- 最少使用(`LFU`)算法：选择近期最少使用的页面淘汰
- 最近未使用(`NRU`)算法
- 二次机会算法：每个页面拥有2次机会才会被淘汰出去
- ...

## 调度策略

- 先来先调度
- 短作业先调度
- 高优先权先调度，又分为抢占式和非抢占式
- 高响应比优先调度，即根据响应时间/要求服务时间的比重，随着等待时间增加，优先级提高
- 时间片轮转，可以在给定时间内响应所有用户请求
- 多级反馈队列，新任务放置在1的队尾，如果未完成，转移到2的队尾，

## 僵尸进程和孤儿进程

某一子进程的父进程终止后，该进程变成孤儿进程，由`init`接管。

而在父进程执行`wait()`之前，子进程就终止了，那么子进程将成为僵尸进程。它仍然保存着内核进程表中的记录，包含子进程`ID`、终止状态、资源使用数据等信息，等待着父进程调用`wait()`后，内核将其删除。

## 内存分配

- 单一连续分配：适合单用户单任务系统
- 固定分区分配：大程序无法放置分区中，小程序容易产生碎片
- 动态分区分配：
  - 首次适应：从低地址开始查找
  - 最佳适应：空闲分区从小到大排列，找到第一个能满足要求的分区
  - 最坏适应：空闲分区从大到小排列，挑选最大分区
  - 循环首次适应：从上次查找结束的位置开始查找
  - 快速适应：对空闲分区按照大小进行分类，对每一类空闲分区单独设置链表