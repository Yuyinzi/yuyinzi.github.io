---
title: 《Redis设计与实现》读书笔记 第三/四部分
date: 2019-04-15 14:25:56
tags:
- Redis
categories:
- 数据库
---

因为第四部分只挑了感兴趣的部分看，于是将第三第四部分合并起来。主要介绍的有：

- `redis`是如何实现主从一致的
- `redis`的`sentinel`是什么

<!-- more -->

## 第十五章 复制 

用户可以通过执行`SLAVEOF`命令让一个服务器(从服务器)去复制另一个服务器(主服务器)。复制功能包括同步(`sync`)和命令传播(`command propagate`)：

- 同步用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态；
- 命令传播用户当主服务器**被修改**时，让主从服务器恢复到一致状态。 

针对`2.8`版本以前采用的是旧版复制，具有较大的性能缺陷。 

### 旧版复制 

同步操作是通过由从服务器向主服务器发送`SYNC`命令完成的，主要包括两个部分： 

- 主服务器收到命令后，使用`BGSAVE`生成`RDB`，并且将`RDB`文件发送给从服务器，从服务器载入`RDB`文件； 

- 主服务器将执行`BGSAVE`命令(但没执行完)时保存在缓冲区里的写命令发送给从服务器。 

同步操作完毕之后，需要根据命令传播保持主从数据库的一致。但是如果**在命令传播的过程中**，发生了**主从服务器断线**，从服务器仍然会向主服务器发送`SYNC`命令，即主数据库会重新执行`BGSAVE`生成`RDB`文件，其中包含了断线前已经同步的数据，是没有必要的。 

> `SYNC`命令十分耗费资源，因为在生成`RDB`的过程中，会耗费主服务器大量的`CPU`、内存和磁盘`I/O`资源；在发送`RDB`的过程中，会占用主从服务器大量的带宽；接收到`RDB`文件的从服务器需要载入，此时会发生阻塞。 

### 新版复制 

新版复制主要可以解决旧版复制功能处理断线重复复制的低效问题，它使用`PSYNC`替代`SYNC`，具有完整重同步和部分重同步两种模式： 

- 完整重同步用于初次复制情况，和`SYNC`处理方式一致 

- 部分重同步用于处理断线重复制情况，只需要将从服务器缺少的写命令发送给从服务器即可。 

部分重同步的实现在于，需要记录三个部分： 

- 主从服务器的复制偏移量：主服务器通过比对与重服务器中数据的偏移量是否一致，判断主从服务器是否处于一致状态。 

- 主服务器的复制积压缓冲区：当主从数据库的复制偏移量不一致时，会判断复制积压缓冲区中是否存在偏移量之后的数据(**复制积压区是一个固定长度的先进先出队列**)。如果数据仍然存在，则进行部分重同步操作；否则执行完整重同步操作。由于复制积压区固定长度，所以需要针对网络断线情况以及主服务器接受的命令数来合理调整其大小。 

- 服务器的运行`ID`：从服务器中会保存主服务器的运行`ID`，当断线重连后，从服务器会重新发送该`ID`，如果与主服务器`ID`一致，主服务器可以继续执行部分重同步操作，否则执行完整重同步操作。 

如果是初次复制操作，从服务器会发送`PSYNC ? -1`，否则发送`PSYNC <runid> <offset>`，主服务器会根据情况判断进行完整重同步还是部分重同步操作。 

### 复制的实现 

- 客户端设置主服务器的地址和端口，保存到从服务器的`redisServer`中，只有当保存工作完成之后，复制工作才会真正开始； 

- 从服务器与主服务器之间建立套接字连接，从服务器会为它关联一个专门用于处理复制工作的文件事件处理器，负责接收`RDB`文件，接收传播来的写命令等； 

- 从服务器发送`PING`命令，用来检查套接字的读写状态是否正常以及主服务器是否能够正常处理命令请求(若没有出现`PONG`的回复，则表示异常，需要重新建立套接字)； 

- 身份验证，如果主服务器设置了`requirepass`，服务器也需要设置`masterauth`，要么都不设置，否则都会使得从服务器目前的复制工作终端，并从创建套接字开始重新执行，直到身份验证通过或者从服务器主动放弃复制； 

- 从服务器发送`REPLCONF listening-port <port-number>`，主服务器会将该端口号记录在客户端状态中，主要用于`INFO replication`的打印中； 

- 从服务器发送`PSYNC`执行同步，执行以后**主从服务器互为双方的客户端**，因为主服务器需要将缓冲区/复制积压缓冲区的写命令发送给从服务器。 

- 完成同步之后，进入命令传播阶段。 主服务器只要一直讲命令发送给从服务器，从服务器只要一直接收主服务器的命令，就可以保证主从服务器一致了。

### 心跳检测 

**命令传播**阶段，从服务器默认`1s`的频率向主服务器发送`REPLCONF ACK <replication_offset>`，`replication_offset`是从服务器当前的复制偏移量，有三个用途： 

- 检测主从服务器的网络连接，如果主服务器超过`1s`没有收到从服务器的`ACK`命令(可以通过`INFO replication`的`lag`看到)，说明主从服务器的连接出现了故障。 

- 辅助实现`min-slaves`配置，主服务器可以提供`min-slaves-to-write`(要求写入时的从服务器数量)和`min-slaves-max-lag`(要求写入时的从服务器延迟)，防止在不安全的情况下执行写命令。 

- 检测命令丢失，如果在命令传播中发生了写命令丢失的情况，主服务器仍然可以根据复制偏移量将这些数据重新发送给从服务器(类似`TCP`中的`ack`)。 

> 补发缺失数据操作在主从服务器没有断线的情况下执行，部分重同步操作在断线重连的情况下执行。 

## 第十六章 `Sentinel` 

`Sentinel`(哨兵)系统可以监视任意多个主服务器，以及主服务器下的所有从服务器，并且当主服务器下线时将从服务器升级为新的主服务器，选举局部`Sentinel`领头以及`Sentinel`领头。 

### 本质 

可以使用: 

``` shell
$redis-server /path/to/your/sentinel.conf --sentinel 
```

或者 

``` shell
$redis-sentinel /path/to/your/sentinel.conf 
```

启动一个`sentinel`服务器。 

实际上，它是一个运行在**特殊模式下的`redis`服务器**。但是它不使用数据库，不会载入`RDB`或者`AOF`文件，端口使用`REDIS_SENTINEL_PORT`指定(普通`redis`服务器端口使用`REDIS_SERVERPORT`)，它只支持`PING`/`SENTINEL`/`INFO`/`SUBSCRIBE`/`UNSUBSCRIBE`/`PSUBSCRIBE`和`PUNSUBSCRIBE`七个命令。 

基本数据结构： 

```C 
struct sentinelState{ 
  // 当前纪元，同一纪元下sentinel领头不能发生变化 
  unint64_t current_epoch; 
  // 记录所有被监视的主服务器相关信息 
  dict * masters; 
  ... 
} 
```

`masters`保存了`sentinelRedisInstance`结构，每一个结构代表被`sentinel`监视的`redis`服务器实例(包括主服务器，从服务器，或者是另外的`sentinel`)。它结构体如下： 

```C 
struct sentinelRedisInstance{ 
  // 实例名字/运行id 
  char * name; 
  char * runid; 
  unit64_t config_epoch; 
  // 实例响应超过down_after_period，会判断主观下线 
  mstime_t down_after_period; 
  // 判断实例客观下线需要的投票数量 
  int quorum; 
  dict * slaves; 
  // 所有监视该服务器的sentinel 
  dict * sentinels; 
  ... 
} 
```

当初始化完成之后，`sentinel`将成为主服务器的客户端。它会与主服务器创建`2`个异步网络连接： 

- 命令连接，用于发送命令与接收命令回复。 

- 订阅连接，用于订阅主服务器的`__sentinel__:hello`频道 

### 获取主服务器信息 

`sentinel`默认每`10s`一次向主服务器发送`INFO`，根据回复可以获得： 

- 主服务器本身的运行`id`，以及`role`域记录的服务器角色； 

- 主服务器下所有从服务器的信息，用来更新主服务器`sentinelRedisInstance`中的`slaves`字典 

### 获取从服务器信息 

由上面所说可以发现，`sentinel`可以自动发现从服务器。

当发现主服务器有新的从服务器出现时，`sentinel`不仅会为新的从服务器创建相应的实例结构，还会**创建到从服务器的命令连接和订阅连接**。也是默认每`10s`向从服务器发送`INFO`，获得从服务器的运行`id`，`ip`以及优先级、偏移量、连接状态等(为了方便以后将从服务器升级为主服务器)。 

### 发现/更新`sentinel`信息 

默认情况下，`sentinel`会每隔`2s`向被监视的主/从服务器的`__sentinel__:hello`频道发送消息。对于监视同一个服务器的多个`sentinel`来说，一个`sentinel`发送的信息会被其他`sentinel`接收，用以互相更新`sentinel`之间的认知：当一个`sentinel`接收到其他`sentinel`(源)发送而来的信息时，会在自己的`masters`字典中查找对应的主服务器实例结构，检查其`sentinels`中是否存在源`sentinel`并进行更新(不存在说明源`sentinel`刚开始监视该主服务器，此时需要创建并添加到`sentinels`中)。因此，监视同一个主服务器的多个`sentinel`可以自动发现对方。 

> 监视同一主服务器的`sentinel`之间会创建命令连接，并不会创建订阅连接。订阅连接用来发现新的`sentinel`。 

### 检测主观/客观下线 

默认情况，`sentinel`会以`1s`的频率向其他创建命令连接的实例(主/从服务器)，其他`sentinel`发送`PING`命令判断实例是否在线。 

**主观下线**： 

如果一个实例在`down_after_milliseconds`时间(这个时间也适用于主服务器下所有从服务器，以及监视主服务器的其他`sentinel`。多个`sentinel`设置的时间可以不同，即不同`sentinel`认为同一实例主观下线的标准并不一致)内连续向`sentinel`返回无效回复，`sentinel`对在创建的实例中的`flags`修改为`SRI_S_DOWN`，表示它认为此实例已经进入主观下线。 

**客观下线**： 

当`sentinel`判断主服务器已经主观下线之后，会向其他监视主服务器的`sentinel`询问是否他们也认为主服务器已经下线。当接收到足够数量(`quorum`)的下线判断时，`sentinel`会将从服务器判定为客观下线(不同`sentinel`认为同一实例客观下线的标准也并不一致)。此时`flags`标记为`SRI_O_DOWN`。客观下线条件只适用于主服务器。

按照我的理解，即使当主服务器被认为下线了，实际上仍然有`sentinel`并不觉得它已主观下线。只要半数以上的`sentinel`认为它已经主观下线，那么这个主服务器其实已经没有当主服务器的必要了，于是可以对它进行故障转移。 

### 选举领头`sentinel` 

只要一个`Sentinel`发现某个主服务器进入了客观下线状态，监视这个下线主服务器的各个`sentinel`会进行协商，选举领头`sentinel`，由其对失效的主服务器执行自动故障迁移操作。 

> 每次领头`sentinel`选举，无论成功与否，配置纪元都会自增一次。局部领头(每个`sentinel`都会要求其他`sentinel`将自己设为局部领头，采取先到先得规则)一旦设置，配置纪元里不能再更改。只有获得半数以上的局部领头，才能真正成为真正的领头。 

### 故障转移 (`failover`)

领头`sentinel`需要对已下线的主服务器执行故障转移： 

- 从从服务器中挑选一个转换为主服务器 

- 让已下线主服务器属下的从服务器改为复制新的主服务器 

- 将已下线主服务器设置为新主服务器的从服务器 

> 在升级从服务器时，领头`sentinel`会以`1s`的频率发送`INFO`命令 

当以前的主服务器上线之后，`Leader`会向其发送`SLAVEOF`命令，使其复制新`master`的数据。(因为需要更改实例中的`masterport`之类的参数)

`Sentinel`集群运行过程中故障转移完成，所有`Sentinel`又会恢复平等。`Leader`仅仅是故障转移操作出现的角色。

`Leader`并不会把自己成为`Leader`的消息发给其他`Sentinel`。其他`Sentinel`等待`Leader`从`slave`选出`master`后，检测到新的`master`正常工作后，就会去掉客观下线的标识，从而不需要进入故障转移流程。